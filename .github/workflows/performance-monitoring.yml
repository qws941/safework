name: SafeWork Performance Monitoring

on:
  schedule:
    - cron: '0 */4 * * *'  # 4시간마다 성능 모니터링
    - cron: '0 9 * * 1'    # 매주 월요일 오전 9시 상세 리포트
  workflow_dispatch:
    inputs:
      monitoring_type:
        description: '모니터링 유형'
        required: true
        default: 'full'
        type: choice
        options:
          - full
          - api_performance
          - database_performance
          - load_test
          - health_check
      duration_minutes:
        description: '모니터링 지속 시간 (분)'
        required: false
        default: '10'
        type: string

env:
  SAFEWORK_BASE_URL: https://safework.jclee.me
  MONITORING_TIMEOUT: 30
  MAX_RESPONSE_TIME: 3000  # 3초

jobs:
  # 🚀 API 성능 테스트
  api-performance-test:
    runs-on: ubuntu-latest
    timeout-minutes: 20
    
    outputs:
      api_performance_score: ${{ steps.api_test.outputs.performance_score }}
      critical_endpoints_failed: ${{ steps.api_test.outputs.critical_failed }}
      
    steps:
      - name: 🚀 SafeWork API 성능 테스트
        id: api_test
        run: |
          echo "🚀 SafeWork API 성능 테스트 시작..."
          echo "⏰ 테스트 시작: $(TZ='Asia/Seoul' date '+%Y-%m-%d %H:%M:%S KST')"
          
          # API 엔드포인트 정의
          declare -A API_ENDPOINTS=(
            ["homepage"]="/"
            ["health"]="/health"
            ["survey_001"]="/survey/001"
            ["survey_002"]="/survey/002" 
            ["admin_login"]="/auth/login"
            ["admin_dashboard"]="/admin"
            ["api_workers"]="/api/safework/v2/workers"
            ["api_health_checks"]="/api/safework/v2/health-checks"
            ["api_statistics"]="/api/safework/v2/statistics"
          )
          
          TOTAL_SCORE=0
          TESTED_COUNT=0
          FAILED_ENDPOINTS=()
          CRITICAL_FAILED=false
          
          echo "🔍 API 엔드포인트 성능 테스트:"
          
          for endpoint_name in "${!API_ENDPOINTS[@]}"; do
            endpoint_path="${API_ENDPOINTS[$endpoint_name]}"
            full_url="${{ env.SAFEWORK_BASE_URL }}$endpoint_path"
            
            echo "📊 테스트 중: $endpoint_name ($endpoint_path)"
            
            # 응답 시간 측정 (3번 시도)
            RESPONSE_TIMES=()
            SUCCESS_COUNT=0
            
            for i in {1..3}; do
              start_time=$(date +%s%N)
              response_code=$(curl -s -o /dev/null -w "%{http_code}" \
                --connect-timeout ${{ env.MONITORING_TIMEOUT }} \
                --max-time ${{ env.MONITORING_TIMEOUT }} \
                "$full_url" || echo "000")
              end_time=$(date +%s%N)
              
              response_time_ms=$(( (end_time - start_time) / 1000000 ))
              
              if [ "$response_code" -eq 200 ] || [ "$response_code" -eq 302 ] || [ "$response_code" -eq 401 ]; then
                RESPONSE_TIMES+=($response_time_ms)
                SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
                echo "  ✓ 시도 $i: ${response_time_ms}ms (HTTP $response_code)"
              else
                echo "  ✗ 시도 $i: 실패 (HTTP $response_code)"
              fi
            done
            
            # 평균 응답 시간 계산
            if [ $SUCCESS_COUNT -gt 0 ]; then
              total_time=0
              for time in "${RESPONSE_TIMES[@]}"; do
                total_time=$((total_time + time))
              done
              avg_time=$((total_time / SUCCESS_COUNT))
              
              # 성능 점수 계산 (응답시간 기준)
              if [ $avg_time -lt 1000 ]; then
                endpoint_score=100
                echo "  🟢 평균: ${avg_time}ms (우수)"
              elif [ $avg_time -lt 2000 ]; then
                endpoint_score=80
                echo "  🟡 평균: ${avg_time}ms (양호)"
              elif [ $avg_time -lt ${{ env.MAX_RESPONSE_TIME }} ]; then
                endpoint_score=60
                echo "  🟠 평균: ${avg_time}ms (보통)"
              else
                endpoint_score=30
                echo "  🔴 평균: ${avg_time}ms (느림)"
              fi
              
              TOTAL_SCORE=$((TOTAL_SCORE + endpoint_score))
              TESTED_COUNT=$((TESTED_COUNT + 1))
              
            else
              echo "  ❌ $endpoint_name 완전 실패"
              FAILED_ENDPOINTS+=("$endpoint_name")
              
              # 중요 엔드포인트 실패 체크
              if [[ "$endpoint_name" == "health" || "$endpoint_name" == "homepage" || "$endpoint_name" == "survey_001" ]]; then
                CRITICAL_FAILED=true
              fi
            fi
          done
          
          # 전체 성능 점수 계산
          if [ $TESTED_COUNT -gt 0 ]; then
            OVERALL_SCORE=$((TOTAL_SCORE / TESTED_COUNT))
          else
            OVERALL_SCORE=0
          fi
          
          echo "📊 API 성능 테스트 결과:"
          echo "  - 테스트된 엔드포인트: $TESTED_COUNT개"
          echo "  - 실패한 엔드포인트: ${#FAILED_ENDPOINTS[@]}개"
          echo "  - 전체 성능 점수: $OVERALL_SCORE/100"
          
          if [ ${#FAILED_ENDPOINTS[@]} -gt 0 ]; then
            echo "  - 실패 목록: ${FAILED_ENDPOINTS[*]}"
          fi
          
          echo "performance_score=$OVERALL_SCORE" >> $GITHUB_OUTPUT
          echo "critical_failed=$CRITICAL_FAILED" >> $GITHUB_OUTPUT
          echo "failed_endpoints=${FAILED_ENDPOINTS[*]}" >> $GITHUB_OUTPUT

  # 🗄️ 데이터베이스 성능 모니터링 (간접)
  database-health-check:
    runs-on: ubuntu-latest 
    timeout-minutes: 15
    
    outputs:
      db_performance_score: ${{ steps.db_test.outputs.db_score }}
      
    steps:
      - name: 🗄️ 데이터베이스 성능 간접 테스트
        id: db_test
        run: |
          echo "🗄️ 데이터베이스 성능 간접 테스트..."
          
          # API를 통한 데이터베이스 응답 시간 테스트
          DB_ENDPOINTS=(
            "/api/safework/v2/workers"
            "/api/safework/v2/health-checks"
            "/api/safework/v2/statistics" 
            "/survey/001"
            "/admin"
          )
          
          TOTAL_DB_SCORE=0
          TESTED_DB_COUNT=0
          
          for endpoint in "${DB_ENDPOINTS[@]}"; do
            echo "🔍 DB 연동 테스트: $endpoint"
            
            start_time=$(date +%s%N)
            response_code=$(curl -s -o /dev/null -w "%{http_code}" \
              --connect-timeout 15 \
              --max-time 15 \
              "${{ env.SAFEWORK_BASE_URL }}$endpoint" || echo "000")
            end_time=$(date +%s%N)
            
            response_time_ms=$(( (end_time - start_time) / 1000000 ))
            
            if [ "$response_code" -eq 200 ] || [ "$response_code" -eq 302 ] || [ "$response_code" -eq 401 ]; then
              # DB 응답 시간 기준 점수
              if [ $response_time_ms -lt 2000 ]; then
                db_score=100
                echo "  🟢 DB 응답: ${response_time_ms}ms (우수)"
              elif [ $response_time_ms -lt 4000 ]; then
                db_score=80
                echo "  🟡 DB 응답: ${response_time_ms}ms (양호)"
              elif [ $response_time_ms -lt 6000 ]; then
                db_score=60
                echo "  🟠 DB 응답: ${response_time_ms}ms (보통)"
              else
                db_score=40
                echo "  🔴 DB 응답: ${response_time_ms}ms (느림)"
              fi
              
              TOTAL_DB_SCORE=$((TOTAL_DB_SCORE + db_score))
              TESTED_DB_COUNT=$((TESTED_DB_COUNT + 1))
            else
              echo "  ❌ DB 연동 실패: HTTP $response_code"
            fi
          done
          
          if [ $TESTED_DB_COUNT -gt 0 ]; then
            OVERALL_DB_SCORE=$((TOTAL_DB_SCORE / TESTED_DB_COUNT))
          else
            OVERALL_DB_SCORE=0
          fi
          
          echo "🗄️ 데이터베이스 성능 점수: $OVERALL_DB_SCORE/100"
          echo "db_score=$OVERALL_DB_SCORE" >> $GITHUB_OUTPUT

  # 📊 부하 테스트 (가벼운 수준)
  light-load-test:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    outputs:
      load_test_score: ${{ steps.load_test.outputs.load_score }}
      
    steps:
      - name: 📊 SafeWork 가벼운 부하 테스트
        id: load_test
        run: |
          echo "📊 SafeWork 가벼운 부하 테스트..."
          
          # 동시 요청 테스트 (5개 동시 연결)
          TEST_URL="${{ env.SAFEWORK_BASE_URL }}/health"
          CONCURRENT_REQUESTS=5
          TOTAL_REQUESTS=20
          
          echo "🔄 동시성 테스트: $CONCURRENT_REQUESTS 동시 연결, 총 $TOTAL_REQUESTS 요청"
          
          SUCCESS_COUNT=0
          TOTAL_TIME=0
          
          # 부하 테스트 실행
          for batch in $(seq 1 $((TOTAL_REQUESTS / CONCURRENT_REQUESTS))); do
            echo "📊 배치 $batch 실행 중..."
            
            # 백그라운드로 동시 요청 실행
            PIDS=()
            START_TIME=$(date +%s%N)
            
            for i in $(seq 1 $CONCURRENT_REQUESTS); do
              (
                response_code=$(curl -s -o /dev/null -w "%{http_code}" \
                  --connect-timeout 10 --max-time 10 \
                  "$TEST_URL" || echo "000")
                if [ "$response_code" -eq 200 ]; then
                  echo "SUCCESS"
                else
                  echo "FAILED:$response_code"
                fi
              ) &
              PIDS+=($!)
            done
            
            # 모든 요청 완료 대기
            SUCCESS_IN_BATCH=0
            for pid in "${PIDS[@]}"; do
              result=$(wait $pid && echo "SUCCESS" || echo "FAILED")
              if [ "$result" = "SUCCESS" ]; then
                SUCCESS_IN_BATCH=$((SUCCESS_IN_BATCH + 1))
              fi
            done
            
            END_TIME=$(date +%s%N)
            BATCH_TIME=$(( (END_TIME - START_TIME) / 1000000 ))
            
            SUCCESS_COUNT=$((SUCCESS_COUNT + SUCCESS_IN_BATCH))
            TOTAL_TIME=$((TOTAL_TIME + BATCH_TIME))
            
            echo "  ✓ 배치 $batch: $SUCCESS_IN_BATCH/$CONCURRENT_REQUESTS 성공, ${BATCH_TIME}ms"
            
            # 배치 간 짧은 휴식
            sleep 2
          done
          
          # 부하 테스트 결과 분석
          SUCCESS_RATE=$((SUCCESS_COUNT * 100 / TOTAL_REQUESTS))
          AVG_BATCH_TIME=$((TOTAL_TIME / (TOTAL_REQUESTS / CONCURRENT_REQUESTS)))
          
          echo "📊 부하 테스트 결과:"
          echo "  - 총 요청: $TOTAL_REQUESTS개"
          echo "  - 성공 요청: $SUCCESS_COUNT개"
          echo "  - 성공률: $SUCCESS_RATE%"
          echo "  - 평균 배치 시간: ${AVG_BATCH_TIME}ms"
          
          # 부하 테스트 점수 계산
          if [ $SUCCESS_RATE -ge 95 ] && [ $AVG_BATCH_TIME -lt 3000 ]; then
            LOAD_SCORE=100
            echo "  🟢 부하 처리 능력: 우수"
          elif [ $SUCCESS_RATE -ge 90 ] && [ $AVG_BATCH_TIME -lt 5000 ]; then
            LOAD_SCORE=80
            echo "  🟡 부하 처리 능력: 양호"
          elif [ $SUCCESS_RATE -ge 80 ] && [ $AVG_BATCH_TIME -lt 8000 ]; then
            LOAD_SCORE=60
            echo "  🟠 부하 처리 능력: 보통"
          else
            LOAD_SCORE=40
            echo "  🔴 부하 처리 능력: 개선 필요"
          fi
          
          echo "load_score=$LOAD_SCORE" >> $GITHUB_OUTPUT

  # 📈 종합 성능 리포트 및 알림
  performance-report:
    needs: [api-performance-test, database-health-check, light-load-test]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    steps:
      - name: 📈 SafeWork 종합 성능 리포트 생성
        id: report
        run: |
          echo "📈 SafeWork 종합 성능 리포트 생성..."
          echo "⏰ 리포트 생성 시간: $(TZ='Asia/Seoul' date '+%Y-%m-%d %H:%M:%S KST')"
          
          # 성능 점수 수집
          API_SCORE="${{ needs.api-performance-test.outputs.api_performance_score }}"
          DB_SCORE="${{ needs.database-health-check.outputs.db_performance_score }}"
          LOAD_SCORE="${{ needs.light-load-test.outputs.load_test_score }}"
          
          echo "📊 개별 성능 점수:"
          echo "  - API 성능: ${API_SCORE:-0}/100"
          echo "  - DB 성능: ${DB_SCORE:-0}/100"
          echo "  - 부하 처리: ${LOAD_SCORE:-0}/100"
          
          # 전체 성능 점수 계산 (가중평균)
          API_WEIGHT=40
          DB_WEIGHT=35
          LOAD_WEIGHT=25
          
          TOTAL_SCORE=$(( (API_SCORE * API_WEIGHT + DB_SCORE * DB_WEIGHT + LOAD_SCORE * LOAD_WEIGHT) / 100 ))
          
          echo "🎯 전체 성능 점수: $TOTAL_SCORE/100"
          
          # 성능 등급 결정
          if [ $TOTAL_SCORE -ge 90 ]; then
            GRADE="A"
            GRADE_DESC="우수"
            GRADE_COLOR="🟢"
          elif [ $TOTAL_SCORE -ge 80 ]; then
            GRADE="B" 
            GRADE_DESC="양호"
            GRADE_COLOR="🟡"
          elif [ $TOTAL_SCORE -ge 70 ]; then
            GRADE="C"
            GRADE_DESC="보통"
            GRADE_COLOR="🟠"
          else
            GRADE="D"
            GRADE_DESC="개선 필요"
            GRADE_COLOR="🔴"
          fi
          
          echo "$GRADE_COLOR 성능 등급: $GRADE ($GRADE_DESC)"
          
          # 중요한 문제 확인
          CRITICAL_ISSUES=()
          if [ "${{ needs.api-performance-test.outputs.critical_endpoints_failed }}" = "true" ]; then
            CRITICAL_ISSUES+=("중요 API 엔드포인트 실패")
          fi
          
          if [ $API_SCORE -lt 60 ]; then
            CRITICAL_ISSUES+=("API 성능 저하")
          fi
          
          if [ $DB_SCORE -lt 60 ]; then
            CRITICAL_ISSUES+=("데이터베이스 성능 저하")
          fi
          
          if [ $LOAD_SCORE -lt 60 ]; then
            CRITICAL_ISSUES+=("부하 처리 능력 저하")
          fi
          
          echo "performance_grade=$GRADE" >> $GITHUB_OUTPUT
          echo "total_score=$TOTAL_SCORE" >> $GITHUB_OUTPUT
          echo "critical_issues_count=${#CRITICAL_ISSUES[@]}" >> $GITHUB_OUTPUT
          
          if [ ${#CRITICAL_ISSUES[@]} -gt 0 ]; then
            echo "🚨 중요 성능 이슈 ${#CRITICAL_ISSUES[@]}건 발견:"
            printf '  - %s\n' "${CRITICAL_ISSUES[@]}"
            echo "PERFORMANCE_ALERT=true" >> $GITHUB_ENV
          else
            echo "✅ 중요 성능 이슈 없음"
          fi

      - name: 📊 성능 모니터링 대시보드 업데이트
        run: |
          echo "📊 성능 모니터링 대시보드 업데이트..."
          
          # 성능 히스토리 로그 생성 (구조화된 형태)
          echo "PERFORMANCE_LOG|$(date -u +%Y-%m-%dT%H:%M:%SZ)|${{ steps.report.outputs.total_score }}|${{ steps.report.outputs.performance_grade }}|API:${{ needs.api-performance-test.outputs.api_performance_score }}|DB:${{ needs.database-health-check.outputs.db_performance_score }}|LOAD:${{ needs.light-load-test.outputs.load_test_score }}"
          
          # 성능 트렌드 분석을 위한 메트릭 저장
          echo "📈 성능 메트릭 기록 완료"

      - name: 🚨 성능 저하 알림 이슈 생성
        if: env.PERFORMANCE_ALERT == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const currentTime = new Date().toLocaleString('ko-KR', {timeZone: 'Asia/Seoul'});
            
            const performanceIssue = {
              title: '📉 [성능저하] SafeWork 시스템 성능 문제 감지',
              body: `
            # 📉 SafeWork 성능 저하 감지됨
            
            **⏰ 감지 시간:** ${currentTime}
            **🎯 전체 성능 점수:** ${{ steps.report.outputs.total_score }}/100 (등급: ${{ steps.report.outputs.performance_grade }})
            **🚨 중요 이슈:** ${{ steps.report.outputs.critical_issues_count }}건
            
            ## 📊 세부 성능 분석
            
            ### 🚀 API 성능
            - **점수:** ${{ needs.api-performance-test.outputs.api_performance_score }}/100
            - **중요 엔드포인트 실패:** ${{ needs.api-performance-test.outputs.critical_endpoints_failed }}
            - **실패 엔드포인트:** ${{ needs.api-performance-test.outputs.failed_endpoints }}
            
            ### 🗄️ 데이터베이스 성능  
            - **점수:** ${{ needs.database-health-check.outputs.db_performance_score }}/100
            - **상태:** DB 연동 API 응답 시간 기반 측정
            
            ### 📊 부하 처리 능력
            - **점수:** ${{ needs.light-load-test.outputs.load_test_score }}/100
            - **동시 연결:** 5개 연결로 테스트
            
            ## 🎯 권장 조치사항
            
            ### 즉시 확인 필요 (1-2시간 내)
            - [ ] **서비스 상태 확인**: https://safework.jclee.me/health
            - [ ] **서버 리소스 점검**: CPU, 메모리, 디스크 사용률
            - [ ] **데이터베이스 상태**: MySQL 연결 및 쿼리 성능
            - [ ] **Redis 캐시 상태**: 캐시 히트율 및 메모리 사용량
            
            ### 단기 개선 방안 (1-3일 내)  
            - [ ] **SQL 쿼리 최적화**: 느린 쿼리 식별 및 개선
            - [ ] **인덱스 최적화**: 자주 사용되는 검색 조건에 인덱스 추가
            - [ ] **캐시 전략 개선**: Redis 캐싱 패턴 최적화
            - [ ] **API 응답 최적화**: 불필요한 데이터 전송 제거
            
            ### 중기 최적화 (1-2주 내)
            - [ ] **코드 프로파일링**: 성능 병목 지점 식별
            - [ ] **데이터베이스 구조 최적화**: 정규화 및 파티셔닝 검토
            - [ ] **CDN 도입**: 정적 자원 로딩 속도 개선
            - [ ] **로드밸런싱**: 트래픽 분산 고려
            
            ## 📞 성능 모니터링 링크
            
            - **실시간 모니터링**: https://safework.jclee.me/health
            - **관리자 대시보드**: https://safework.jclee.me/admin
            - **API 상태**: https://safework.jclee.me/api/safework/v2
            
            ## 🤖 자동화 지원
            
            **즉시 분석 요청:** @claude 이 성능 이슈를 분석하고 구체적인 최적화 방안을 제시해주세요.
            
            ---
            🤖 *SafeWork 자동 성능 모니터링 시스템*`,
              labels: ['📈 개선요청', '⚡ 성능', 'P1-HIGH']
            };
            
            const { data: issue } = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ...performanceIssue
            });
            
            console.log(`📉 성능 저하 알림 이슈 생성됨: #${issue.number}`);
            
            // Claude AI 자동 호출 (성능 문제 즉시 분석)
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: '@claude SafeWork 시스템 성능 저하가 감지되었습니다. 즉시 성능 분석을 수행하고 단계별 최적화 방안을 제시해주세요. 우선순위: P1-HIGH'
            });

      - name: 🎉 성능 모니터링 완료 알림
        if: env.PERFORMANCE_ALERT != 'true'
        run: |
          echo "🎉 SafeWork 성능 모니터링 완료!"
          echo "📊 전체 성능 점수: ${{ steps.report.outputs.total_score }}/100"
          echo "🏆 성능 등급: ${{ steps.report.outputs.performance_grade }}"
          echo "✅ 모든 성능 지표가 정상 범위입니다."
          echo "⏰ 다음 모니터링: 4시간 후"