name: 🚀 Deploy Pipeline

# Prevent duplicate workflow execution
concurrency:
  group: deploy-${{ github.ref }}
  cancel-in-progress: true

on:
  push:
    branches: [main, master, develop]
    paths:
      - 'app/**'
      - 'postgres/**'
      - 'redis/**'
      - 'requirements.txt'
      - 'Dockerfile*'
      - 'docker-compose*.yml'
      - 'tests/**'
      - '.github/workflows/deploy.yml'
  
  workflow_dispatch:
    inputs:
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: false
        type: boolean
      skip_tests:
        description: 'Skip test execution'
        required: false
        default: false
        type: boolean

env:
  APP_NAME: ${{ github.event.repository.name }}
  REGISTRY_HOST: ${{ secrets.REGISTRY_HOST || 'registry.jclee.me' }}
  REGISTRY_USER: ${{ secrets.REGISTRY_USER || 'admin' }}
  TZ: Asia/Seoul
  PRD_URL: ${{ secrets.PRD_URL || format('https://{0}.jclee.me', github.event.repository.name) }}
  DEV_URL: ${{ secrets.DEV_URL || format('https://{0}-dev.jclee.me', github.event.repository.name) }}
  PORTAINER_URL: ${{ secrets.PORTAINER_URL || 'https://portainer.jclee.me' }}

permissions:
  contents: write
  packages: write
  actions: write
  id-token: write
  issues: write
  pull-requests: write
  repository-projects: write
  security-events: write
  statuses: write
  checks: write
  deployments: write
  pages: write
  metadata: read

jobs:
  # Phase 1: Build and Test
  build-and-test:
    name: 🔨 Build & Test
    runs-on: ubuntu-latest
    outputs:
      app_image_tag: ${{ steps.app_meta.outputs.tags }}
      postgres_image_tag: ${{ steps.postgres_meta.outputs.tags }}
      redis_image_tag: ${{ steps.redis_meta.outputs.tags }}
      test_results: ${{ steps.test.outputs.results }}
      build_status: ${{ steps.build.outputs.build_status }}
      
    steps:
      - name: 📂 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🐳 Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🔐 Login to Registry  
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_HOST }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ secrets.REGISTRY_PASSWORD }}

      # Metadata for PostgreSQL image
      - name: 📋 Extract PostgreSQL Metadata
        id: postgres_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}-postgres
          tags: |
            type=raw,value=latest

      # Metadata for Redis image
      - name: 📋 Extract Redis Metadata
        id: redis_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}-redis
          tags: |
            type=raw,value=latest

      # Metadata for Flask App image
      - name: 📋 Extract App Metadata
        id: app_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}-app
          tags: |
            type=raw,value=latest

      # Build PostgreSQL image
      - name: 🔨 Build PostgreSQL Image
        id: build_postgres
        uses: docker/build-push-action@v5
        with:
          context: ./postgres
          file: ./postgres/Dockerfile
          push: true
          tags: ${{ steps.postgres_meta.outputs.tags }}
          labels: |
            ${{ steps.postgres_meta.outputs.labels }}
            com.docker.compose.project=${{ env.APP_NAME }}
            com.docker.compose.service=postgres
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ github.sha }}
            BUILD_NUMBER=${{ github.run_number }}
            VCS_REF=${{ github.sha }}
            BUILDTIME=${{ github.event.head_commit.timestamp }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB || 'safework_db' }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER || 'safework' }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || 'safework2024' }}

      # Build Redis image
      - name: 🔨 Build Redis Image
        id: build_redis
        uses: docker/build-push-action@v5
        with:
          context: ./redis
          file: ./redis/Dockerfile
          push: true
          tags: ${{ steps.redis_meta.outputs.tags }}
          labels: |
            ${{ steps.redis_meta.outputs.labels }}
            com.docker.compose.project=${{ env.APP_NAME }}
            com.docker.compose.service=redis
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ github.sha }}
            BUILD_NUMBER=${{ github.run_number }}
            VCS_REF=${{ github.sha }}
            BUILDTIME=${{ github.event.head_commit.timestamp }}

      # Build Flask App image
      - name: 🔨 Build Flask App Image
        id: build_app
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/Dockerfile
          push: true
          tags: ${{ steps.app_meta.outputs.tags }}
          labels: |
            ${{ steps.app_meta.outputs.labels }}
            com.docker.compose.project=${{ env.APP_NAME }}
            com.docker.compose.service=app
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ github.sha }}
            BUILD_TIME=${{ github.event.head_commit.timestamp }}
            BUILD_NUMBER=${{ github.run_number }}
            VCS_REF=${{ github.sha }}
            BUILDTIME=${{ github.event.head_commit.timestamp }}
            POSTGRES_HOST=${{ secrets.POSTGRES_HOST || 'safework-postgres' }}
            POSTGRES_PORT=${{ secrets.POSTGRES_PORT || '5432' }}
            POSTGRES_DB=${{ secrets.POSTGRES_DB || 'safework_db' }}
            POSTGRES_USER=${{ secrets.POSTGRES_USER || 'safework' }}
            POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD || 'safework2024' }}
            REDIS_HOST=${{ secrets.REDIS_HOST || 'safework-redis' }}
            REDIS_PORT=${{ secrets.REDIS_PORT || '6379' }}
            PRD_URL=${{ secrets.PRD_URL }}
            DEV_URL=${{ secrets.DEV_URL }}
            GITHUB_TOKEN=${{ secrets.GITHUB_TOKEN }}
            GITHUB_REPO_OWNER=${{ github.repository_owner }}
            GITHUB_REPO_NAME=${{ github.event.repository.name }}
            REGISTRY_HOST=${{ secrets.REGISTRY_HOST }}
            REGISTRY_USER=${{ secrets.REGISTRY_USER }}
            REGISTRY_PASSWORD=${{ secrets.REGISTRY_PASSWORD }}
            FLASK_ENV=production
            ADMIN_USERNAME=${{ secrets.ADMIN_USERNAME || 'admin' }}
            ADMIN_PASSWORD=${{ secrets.ADMIN_PASSWORD || 'safework2024' }}
            SECRET_KEY=${{ secrets.SECRET_KEY || 'safework-production-secret-key-2024' }}
            TIMEZONE=${{ secrets.TIMEZONE || 'Asia/Seoul' }}

      - name: 🧪 Run Tests
        id: test
        if: github.event.inputs.skip_tests != 'true'
        run: |
          echo "🧪 Running Flask application tests..."
          
          # Use Flask app image for testing
          APP_IMAGE_TAG=$(echo "${{ steps.app_meta.outputs.tags }}" | head -n1)
          echo "🐳 Using Flask app image: $APP_IMAGE_TAG"
          
          # Basic container execution test (timeout configured)
          timeout 30s docker run --rm --name ${{ env.APP_NAME }}-test \
            -e FLASK_ENV=testing \
            -e POSTGRES_HOST=localhost \
            -e REDIS_HOST=localhost \
            "$APP_IMAGE_TAG" \
            bash -c "
              echo '✅ Container started successfully'
              python -c 'import sys; print(f\"Python version: {sys.version}\")'
              python -c 'from app import create_app; print(\"Flask app creation test passed\")'
              echo 'test_completed=true'
            " && echo "results=success" >> $GITHUB_OUTPUT || echo "results=failed" >> $GITHUB_OUTPUT

      - name: 📊 Test Results Summary  
        run: |
          echo "### 🧪 Test Results Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Build Status**: ✅ Success" >> $GITHUB_STEP_SUMMARY
          echo "- **PostgreSQL Image**: \`${{ steps.postgres_meta.outputs.tags }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Redis Image**: \`${{ steps.redis_meta.outputs.tags }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Flask App Image**: \`${{ steps.app_meta.outputs.tags }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Test Status**: ${{ steps.test.outputs.results }}" >> $GITHUB_STEP_SUMMARY

  # Phase 2: Deploy Execution
  deploy:
    name: 🚀 Deploy to Production
    needs: build-and-test
    runs-on: ubuntu-latest
    if: success() || github.event.inputs.force_deploy == 'true'
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      deployment_url: ${{ steps.deploy.outputs.url }}
      deployment_time: ${{ steps.deploy.outputs.time }}
      health_check: ${{ steps.health.outputs.status }}

    steps:
      - name: 🚀 Deploy Containers via Portainer API
        id: deploy
        env:
          APP_NAME: safework2
          PORTAINER_URL: ${{ secrets.PORTAINER_URL || 'https://portainer.jclee.me' }}
          PORTAINER_TOKEN: ${{ secrets.PORTAINER_API_TOKEN }}
          PORTAINER_ENDPOINT_ID: ${{ secrets.PORTAINER_ENDPOINT_ID || '1' }}
        run: |
          echo "🚀 Starting Portainer API deployment process..."
          
          # Function to ensure network exists
          ensure_network() {
            local NETWORK_NAME=$1
            echo "Ensuring network: $NETWORK_NAME"
            
            # Check if network exists
            NETWORK_EXISTS=$(curl -s "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/networks" \
              -H "X-API-Key: $PORTAINER_TOKEN" | \
              jq -r --arg name "$NETWORK_NAME" '.[] | select(.Name == $name) | .Name')
            
            if [ -z "$NETWORK_EXISTS" ]; then
              echo "Creating network: $NETWORK_NAME"
              curl -X POST "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/networks/create" \
                -H "X-API-Key: $PORTAINER_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{
                  \"Name\": \"$NETWORK_NAME\",
                  \"Driver\": \"bridge\",
                  \"EnableIPv6\": false,
                  \"IPAM\": {
                    \"Driver\": \"default\"
                  }
                }"
            else
              echo "Network already exists: $NETWORK_NAME"
            fi
          }
          
          # Function to ensure volume exists
          ensure_volume() {
            local VOLUME_NAME=$1
            echo "Ensuring volume: $VOLUME_NAME"
            
            # Check if volume exists
            VOLUME_EXISTS=$(curl -s "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/volumes" \
              -H "X-API-Key: $PORTAINER_TOKEN" | \
              jq -r --arg name "$VOLUME_NAME" '.Volumes[]? | select(.Name == $name) | .Name')
            
            if [ -z "$VOLUME_EXISTS" ]; then
              echo "Creating volume: $VOLUME_NAME"
              curl -X POST "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/volumes/create" \
                -H "X-API-Key: $PORTAINER_TOKEN" \
                -H "Content-Type: application/json" \
                -d "{\"Name\": \"$VOLUME_NAME\"}"
            else
              echo "Volume already exists: $VOLUME_NAME"
            fi
          }
          
          # Function to deploy container
          deploy_container() {
            local CONTAINER_NAME=$1
            local IMAGE=$2
            local ENV_VARS=$3
            local HEALTH_CMD=$4
            local VOLUMES=$5
            local PORT_BINDINGS=$6
            local MEMORY=$7
            local CPU_SHARES=$8
            local NETWORK=$9
            
            echo "Deploying container: $CONTAINER_NAME"
            
            # Check if container exists and stop/remove it
            CONTAINER_EXISTS=$(curl -s "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/containers/json?all=true" \
              -H "X-API-Key: $PORTAINER_TOKEN" | \
              jq -r --arg name "$CONTAINER_NAME" '.[]? | select(.Names[]? | contains($name)) | .Id')
            
            if [ -n "$CONTAINER_EXISTS" ]; then
              echo "Stopping existing container..."
              curl -X POST "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/containers/$CONTAINER_EXISTS/stop" \
                -H "X-API-Key: $PORTAINER_TOKEN"
              
              echo "Removing existing container..."
              curl -X DELETE "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/containers/$CONTAINER_EXISTS" \
                -H "X-API-Key: $PORTAINER_TOKEN"
            fi
            
            # Pull latest image
            echo "Pulling latest image: $IMAGE"
            curl -X POST "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/images/create?fromImage=$IMAGE" \
              -H "X-API-Key: $PORTAINER_TOKEN"
            
            # Create container configuration
            CONTAINER_CONFIG="{
              \"Image\": \"$IMAGE\",
              \"Env\": $ENV_VARS,
              \"NetworkingConfig\": {
                \"EndpointsConfig\": {
                  \"$NETWORK\": {}
                }
              },
              \"HostConfig\": {
                \"RestartPolicy\": {
                  \"Name\": \"unless-stopped\",
                  \"MaximumRetryCount\": 5
                },
                \"NetworkMode\": \"$NETWORK\",
                \"Binds\": $VOLUMES,
                \"Memory\": $MEMORY,
                \"CpuShares\": $CPU_SHARES"
            
            if [ -n "$PORT_BINDINGS" ] && [ "$PORT_BINDINGS" != "null" ]; then
              CONTAINER_CONFIG="$CONTAINER_CONFIG,
                \"PortBindings\": $PORT_BINDINGS"
            fi
            
            CONTAINER_CONFIG="$CONTAINER_CONFIG
              },
              \"Healthcheck\": $HEALTH_CMD
            }"
            
            # Create new container
            curl -X POST "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/containers/create?name=$CONTAINER_NAME" \
              -H "X-API-Key: $PORTAINER_TOKEN" \
              -H "Content-Type: application/json" \
              -d "$CONTAINER_CONFIG"
            
            # Start the container
            echo "Starting container..."
            NEW_CONTAINER_ID=$(curl -s "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/containers/json?all=true" \
              -H "X-API-Key: $PORTAINER_TOKEN" | \
              jq -r --arg name "$CONTAINER_NAME" '.[]? | select(.Names[]? | contains($name)) | .Id')
            
            if [ -n "$NEW_CONTAINER_ID" ]; then
              curl -X POST "$PORTAINER_URL/api/endpoints/$PORTAINER_ENDPOINT_ID/docker/containers/$NEW_CONTAINER_ID/start" \
                -H "X-API-Key: $PORTAINER_TOKEN"
              echo "Container deployed: $CONTAINER_NAME"
            else
              echo "Failed to create container: $CONTAINER_NAME"
              return 1
            fi
          }
          
          # Create network and volumes
          ensure_network "${APP_NAME}-network"
          ensure_volume "${APP_NAME}-postgres-data"
          ensure_volume "${APP_NAME}-redis-data"
          ensure_volume "${APP_NAME}-app-uploads"
          ensure_volume "${APP_NAME}-app-logs"
          ensure_volume "${APP_NAME}-app-cache"
          
          # Deploy PostgreSQL container
          if deploy_container \
            "${APP_NAME}-postgres" \
            "${{ needs.build-and-test.outputs.postgres_image_tag }}" \
            '["POSTGRES_DB=safework_db", "POSTGRES_USER=safework", "POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}"]' \
            '{"Test": ["CMD-SHELL", "pg_isready -U safework"], "Interval": 30000000000, "Timeout": 10000000000, "Retries": 3}' \
            '["'${APP_NAME}'-postgres-data:/var/lib/postgresql/data"]' \
            '{"5432/tcp": [{"HostPort": "4546"}]}' \
            1073741824 \
            512 \
            "${APP_NAME}-network"; then
            echo "✅ PostgreSQL container deployed successfully"
          else
            echo "❌ PostgreSQL container deployment failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          sleep 10  # Wait for PostgreSQL to initialize
          
          # Deploy Redis container
          if deploy_container \
            "${APP_NAME}-redis" \
            "${{ needs.build-and-test.outputs.redis_image_tag }}" \
            '[]' \
            '{"Test": ["CMD", "redis-cli", "ping"], "Interval": 30000000000, "Timeout": 10000000000, "Retries": 3}' \
            '["'${APP_NAME}'-redis-data:/data"]' \
            '{"6379/tcp": [{"HostPort": "4547"}]}' \
            268435456 \
            256 \
            "${APP_NAME}-network"; then
            echo "✅ Redis container deployed successfully"
          else
            echo "❌ Redis container deployment failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          sleep 5  # Wait for Redis to initialize
          
          # Deploy App container
          if deploy_container \
            "${APP_NAME}-app" \
            "${{ needs.build-and-test.outputs.app_image_tag }}" \
            '["POSTGRES_HOST='${APP_NAME}'-postgres", "POSTGRES_PORT=5432", "REDIS_HOST='${APP_NAME}'-redis", "REDIS_PORT=6379", "FLASK_ENV=production"]' \
            '{"Test": ["CMD", "curl", "-f", "http://localhost:4545/health"], "Interval": 30000000000, "Timeout": 10000000000, "Retries": 3}' \
            '["'${APP_NAME}'-app-uploads:/app/uploads", "'${APP_NAME}'-app-logs:/app/logs", "'${APP_NAME}'-app-cache:/app/cache"]' \
            '{"4545/tcp": [{"HostPort": "4545"}]}' \
            536870912 \
            512 \
            "${APP_NAME}-network"; then
            echo "✅ App container deployed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
            echo "url=${{ env.PRD_URL }}" >> $GITHUB_OUTPUT
            echo "time=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT
          else
            echo "❌ App container deployment failed"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: ⏳ Wait for Deployment Stabilization
        if: steps.deploy.outputs.status == 'success'
        run: |
          echo "⏳ Waiting for container deployment to complete..."
          sleep 60  # Extended wait for proper initialization

      - name: 🏥 Health Check
        id: health
        if: steps.deploy.outputs.status == 'success'
        run: |
          echo "🏥 Performing health checks..."
          
          # Check application health endpoint
          if timeout 30s curl -sf --max-time 10 "${{ env.PRD_URL }}/health" > /dev/null; then
            echo "✅ Application health check passed"
            echo "status=healthy" >> $GITHUB_OUTPUT
          else
            echo "❌ Application health check failed"
            echo "status=unhealthy" >> $GITHUB_OUTPUT
          fi

  # Phase 3: Post-Deployment Notification
  notify:
    name: 📢 Post-Deployment Notification
    needs: [build-and-test, deploy]
    runs-on: ubuntu-latest
    if: always()
    
    steps:
      - name: 📢 Send Deployment Notification
        if: always()
        run: |
          echo "📢 SafeWork deployment completed!"
          echo "- **Status**: ${{ needs.deploy.outputs.deployment_status }}"
          echo "- **URL**: ${{ needs.deploy.outputs.deployment_url }}"
          echo "- **Health**: ${{ needs.deploy.outputs.health_check }}"
          echo "- **Time**: ${{ needs.deploy.outputs.deployment_time }}"