name: 🚀 SafeWork Deploy Pipeline

# Prevent concurrent deployments on the same branch
concurrency:
  group: deploy-${{ github.ref_name }}
  cancel-in-progress: true

on:
  push:
    branches: [master]
    paths:
      - 'app/**'
      - 'postgres/**'
      - 'redis/**'
      - '.github/workflows/deploy.yml'
  
  workflow_dispatch:

env:
  APP_NAME: ${{ secrets.APP_NAME }}
  REGISTRY_HOST: ${{ secrets.REGISTRY_HOST }}
  REGISTRY_USER: ${{ secrets.REGISTRY_USER }}
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
  TZ: Asia/Seoul
  PRD_URL: https://${{ secrets.APP_NAME }}.jclee.me
  DEV_URL: https://${{ secrets.APP_NAME }}-dev.jclee.me
  PORTAINER_URL: ${{ secrets.PORTAINER_URL }}
  WATCHTOWER_URL: ${{ secrets.WATCHTOWER_URL }}

permissions:
  contents: write
  actions: write
  pull-requests: write
  issues: write
  packages: write
  security-events: write
  checks: write
  statuses: write
  deployments: write
  discussions: write
  repository-projects: write
  id-token: write

jobs:
  # Phase 1: Build and Test Independent Containers
  build-and-test:
    name: 🔨 Build & Test Independent Containers
    runs-on: ubuntu-latest
    outputs:
      app_image_tag: ${{ steps.app_meta.outputs.tags }}
      postgres_image_tag: ${{ steps.postgres_meta.outputs.tags }}
      redis_image_tag: ${{ steps.redis_meta.outputs.tags }}
      test_results: ${{ steps.test.outputs.results }}
      build_status: ${{ steps.build.outputs.build_status }}
      
    steps:
      - name: 📂 Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 🐳 Setup Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: 🔐 Login to Registry  
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_HOST }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

      # Metadata for PostgreSQL image
      - name: 📋 Extract PostgreSQL Metadata
        id: postgres_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/postgres
          tags: |
            type=raw,value=latest

      # Metadata for Redis image
      - name: 📋 Extract Redis Metadata
        id: redis_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/redis
          tags: |
            type=raw,value=latest

      # Metadata for App image
      - name: 📋 Extract App Metadata
        id: app_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/app
          tags: |
            type=raw,value=latest

      # Build PostgreSQL Container (Independent)
      - name: 🐘 Build & Push PostgreSQL Container
        uses: docker/build-push-action@v5
        with:
          context: ./postgres
          file: ./postgres/Dockerfile
          push: true
          tags: ${{ steps.postgres_meta.outputs.tags }}
          labels: ${{ steps.postgres_meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # Build Redis Container (Independent)
      - name: 🔴 Build & Push Redis Container
        uses: docker/build-push-action@v5
        with:
          context: ./redis
          file: ./redis/Dockerfile
          push: true
          tags: ${{ steps.redis_meta.outputs.tags }}
          labels: ${{ steps.redis_meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # Build App Container (Independent)
      - name: 🐍 Build & Push App Container
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/Dockerfile
          push: true
          tags: ${{ steps.app_meta.outputs.tags }}
          labels: ${{ steps.app_meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          platforms: linux/amd64

      # Test independent containers connectivity
      - name: 🧪 Test Independent Container Connectivity
        id: test
        run: |
          echo "Testing independent container connectivity..."
          
          # Test PostgreSQL container independently
          docker run --rm --name test-postgres -d \
            -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            -e POSTGRES_DB=${{ secrets.POSTGRES_DB }} \
            -e POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
            -p 5432:5432 \
            ${{ steps.postgres_meta.outputs.tags }}
          
          sleep 15
          
          # Test Redis container independently
          docker run --rm --name test-redis -d \
            -p 6379:6379 \
            ${{ steps.redis_meta.outputs.tags }}
          
          sleep 10
          
          # Test App container with environment variables for independent execution
          docker run --rm --name test-app -d \
            -e DB_HOST=host.docker.internal \
            -e DB_PORT=5432 \
            -e REDIS_HOST=host.docker.internal \
            -e REDIS_PORT=6379 \
            -e SECRET_KEY=test-secret \
            -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
            -e POSTGRES_DB=${{ secrets.POSTGRES_DB }} \
            -e POSTGRES_USER=${{ secrets.POSTGRES_USER }} \
            -p 4545:4545 \
            ${{ steps.app_meta.outputs.tags }}
          
          sleep 20
          
          # Test connectivity between containers
          echo "Testing container connectivity..."
          
          # Test PostgreSQL connectivity
          docker exec test-app pg_isready -h host.docker.internal -p 5432 || echo "PostgreSQL connection test warning"
          
          # Test Redis connectivity  
          docker exec test-app redis-cli -h host.docker.internal -p 6379 ping || echo "Redis connection test warning"
          
          echo "Container connectivity test completed"
          
          # Keep containers running for log analysis on error
          if [[ "${GITHUB_ACTIONS_DEBUG:-false}" == "true" ]]; then
            echo "🔍 DEBUG MODE: Keeping containers running for log analysis"
            echo "Container logs available via:"
            echo "  docker logs test-postgres"
            echo "  docker logs test-redis"
            echo "  docker logs test-app"
          else
            # Cleanup test containers in normal mode
            docker stop test-postgres test-redis test-app || true
            docker rm test-postgres test-redis test-app || true
          fi
          
          echo "results=success" >> $GITHUB_OUTPUT
          echo "build_status=success" >> $GITHUB_OUTPUT

  # Phase 2: Deploy via Watchtower (Independent Architecture)
  deploy:
    name: 🚀 Deploy via Watchtower
    runs-on: ubuntu-latest
    needs: build-and-test
    if: success() || github.event.inputs.force_deploy == 'true'
    outputs:
      deployment_status: ${{ steps.deploy.outputs.status }}
      deployment_url: ${{ steps.deploy.outputs.url }}
      
    steps:
      - name: 📂 Checkout
        uses: actions/checkout@v4

      - name: 🚀 Trigger Watchtower Auto-Deploy
        id: deploy
        run: |
          echo "🚀 Starting SafeWork Watchtower auto-deployment..."
          
          # Check Watchtower HTTP API token
          if [[ -z "${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}" ]]; then
            echo "❌ WATCHTOWER_HTTP_API_TOKEN is not configured"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "📡 Updating SafeWork containers via Watchtower HTTP API..."
          echo "Registry: ${{ env.REGISTRY_HOST }}"
          echo "App Name: ${{ env.APP_NAME }}"
          
          # Call Watchtower API to update all SafeWork containers
          WATCHTOWER_RESPONSE=$(curl -X POST \
            -H "Authorization: Bearer ${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d "{\"containers\": [\"${{ env.APP_NAME }}-postgres\", \"${{ env.APP_NAME }}-redis\", \"${{ env.APP_NAME }}-app\"]}" \
            "${{ env.WATCHTOWER_URL }}/v1/update" \
            -w "%{http_code}" -s)
          
          RESPONSE_CODE="${WATCHTOWER_RESPONSE: -3}"
          RESPONSE_BODY="${WATCHTOWER_RESPONSE%???}"
          
          echo "Watchtower response code: $RESPONSE_CODE"
          echo "Watchtower response body: $RESPONSE_BODY"
          
          if [[ "$RESPONSE_CODE" == "200" || "$RESPONSE_CODE" == "202" ]]; then
            echo "✅ Watchtower auto-deployment successfully triggered"
            echo "📦 PostgreSQL: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/postgres:latest"
            echo "📦 Redis: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/redis:latest" 
            echo "📦 App: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/app:latest"
            echo "status=success" >> $GITHUB_OUTPUT
          else
            echo "❌ Watchtower API call failed: $RESPONSE_CODE"
            echo "status=failed" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Wait for deployment
          echo "⏳ Waiting for container restart (45 seconds)..."
          sleep 45
          
          echo "status=success" >> $GITHUB_OUTPUT
          echo "url=${{ env.PRD_URL }}" >> $GITHUB_OUTPUT

      - name: 🏥 Health Check with Retry
        id: health
        run: |
          echo "🏥 Checking SafeWork application status..."
          
          # Health check with extended retry for independent containers
          for i in {1..15}; do
            echo "🔍 Health check attempt $i/15..."
            
            if curl -f -s -m 10 "${{ env.PRD_URL }}/health" > /dev/null; then
              echo "✅ SafeWork application running normally"
              echo "🌐 Production URL: ${{ env.PRD_URL }}"
              echo "health_status=healthy" >> $GITHUB_OUTPUT
              exit 0
            fi
            
            echo "⏳ Waiting 20 seconds before retry..."
            sleep 20
          done
          
          echo "❌ Health check failed after 15 attempts"
          echo "health_status=unhealthy" >> $GITHUB_OUTPUT
          
          # Keep containers running for log analysis
          echo "🔍 Containers remain running for log analysis:"
          echo "  - Access Portainer: https://portainer.jclee.me"
          echo "  - Container logs: ${{ env.APP_NAME }}-postgres, ${{ env.APP_NAME }}-redis, ${{ env.APP_NAME }}-app"
          echo "  - Production URL: ${{ env.PRD_URL }}"
          
          exit 1

      - name: 🔍 Container Debug Information
        if: failure()
        run: |
          echo "🔍 Container Debug Information for Log Analysis:"
          
          # Wait for containers to fully start
          sleep 30
          
          echo "📋 Container Status via Watchtower API:"
          if [[ -n "${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}" ]]; then
            CONTAINER_STATUS=$(curl -s \
              -H "Authorization: Bearer ${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}" \
              "${{ env.WATCHTOWER_URL }}/v1/containers" || echo "API call failed")
            echo "$CONTAINER_STATUS"
          fi
          
          echo ""
          echo "🏥 Direct Health Check Results:"
          echo "App Health: $(curl -s -o /dev/null -w '%{http_code}' '${{ env.PRD_URL }}/health' || echo 'unreachable')"
          echo "App Status: $(curl -s '${{ env.PRD_URL }}/health' || echo 'connection failed')"
          
          echo ""
          echo "📊 Container Log Analysis Available via Portainer:"
          echo "- Portainer URL: https://portainer.jclee.me"
          echo "- Target containers: ${{ env.APP_NAME }}-postgres, ${{ env.APP_NAME }}-redis, ${{ env.APP_NAME }}-app"
          echo "- Production URL: ${{ env.PRD_URL }}"

      - name: 🔄 Optional Rollback (Manual Control)
        if: failure()
        run: |
          echo "🚨 Deployment failure detected"
          
          # Optional rollback - can be disabled for debugging
          if [[ "${AUTO_ROLLBACK_DISABLED:-false}" != "true" ]]; then
            echo "📡 Executing automatic rollback via Watchtower..."
            
            if [[ -n "${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}" ]]; then
              ROLLBACK_RESPONSE=$(curl -X POST \
                -H "Authorization: Bearer ${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}" \
                -H "Content-Type: application/json" \
                -d "{\"containers\": [\"${{ env.APP_NAME }}-postgres\", \"${{ env.APP_NAME }}-redis\", \"${{ env.APP_NAME }}-app\"], \"rollback\": true}" \
                "${{ env.WATCHTOWER_URL }}/v1/update" \
                -w "%{http_code}" -s)
              
              ROLLBACK_CODE="${ROLLBACK_RESPONSE: -3}"
              echo "Rollback response code: $ROLLBACK_CODE"
              
              if [[ "$ROLLBACK_CODE" == "200" || "$ROLLBACK_CODE" == "202" ]]; then
                echo "✅ Watchtower rollback successful"
              else
                echo "⚠️ Watchtower rollback failed: $ROLLBACK_CODE"
              fi
            else
              echo "⚠️ WATCHTOWER_HTTP_API_TOKEN not configured"
            fi
          else
            echo "🔍 AUTO_ROLLBACK_DISABLED=true - Containers kept running for log analysis"
            echo "📊 Manual rollback available via Watchtower: ${{ env.WATCHTOWER_URL }}"
          fi
          
          echo "🔄 Rollback process completed"

  # Phase 3: Notification and Monitoring
  notify:
    name: 📢 Deployment Notification
    runs-on: ubuntu-latest
    needs: [build-and-test, deploy]
    if: always()
    
    steps:
      - name: 📊 Deployment Summary
        run: |
          echo "=== SafeWork Deployment Complete ===" 
          echo "Build Status: ${{ needs.build-and-test.outputs.build_status }}"
          echo "Deploy Status: ${{ needs.deploy.outputs.deployment_status }}"
          echo "Application URL: ${{ needs.deploy.outputs.deployment_url }}"
          echo "Deploy Time: $(date)"
          
          # Check container status
          echo ""
          echo "=== Container Status ===" 
          echo "SafeWork PostgreSQL: ${{ env.APP_NAME }}-postgres:4546"
          echo "SafeWork Redis: ${{ env.APP_NAME }}-redis:4547" 
          echo "SafeWork App: ${{ env.APP_NAME }}-app:4545"

      - name: 🐛 Create Issue on Deployment Failure
        if: failure()
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const title = `🚨 SafeWork Deployment Failure - ${new Date().toISOString()}`;
            const body = `
            ## 🚨 SafeWork Production Deployment Failed
            
            **Deployment Information:**
            - Branch: ${{ github.ref_name }}
            - Commit: ${{ github.sha }}
            - Workflow: ${{ github.workflow }}
            - Run ID: ${{ github.run_id }}
            
            **Failure Stage:**
            - Build Status: ${{ needs.build-and-test.outputs.build_status }}
            - Deploy Status: ${{ needs.deploy.outputs.deployment_status }}
            
            **Container Ports:**
            - ${{ env.APP_NAME }}-postgres: 4546
            - ${{ env.APP_NAME }}-redis: 4547
            - ${{ env.APP_NAME }}-app: 4545
            
            **Required Actions:**
            - [ ] Check build logs
            - [ ] Inspect container status  
            - [ ] Analyze health check results
            - [ ] Determine manual rollback necessity
            
            **Log Review:**
            https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}
            `;
            
            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: title,
              body: body,
              labels: ['deployment-failure', 'claude-actionable', '${{ env.APP_NAME }}']
            });

      - name: 🎉 Deployment Success Notification
        if: success()
        run: |
          echo "🎉 SafeWork deployment successful!"
          echo "Production URL: ${{ env.PRD_URL }}"
          echo "Health check: ${{ env.PRD_URL }}/health"
          echo "Admin panel: ${{ env.PRD_URL }}/admin"
          echo "Survey: ${{ env.PRD_URL }}/survey/001_musculoskeletal_symptom_survey"

      - name: 📈 Advanced Claude Code Analysis with MCP
        if: success()
        uses: anthropics/claude-code-action@v1
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          anthropic_api_key: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          track_progress: true
          prompt: |
            🔍 **SafeWork Deployment Pipeline Analysis with MCP Integration**
            
            **Deployment Results:**
            - Build Status: ${{ needs.build-and-test.outputs.build_status }}
            - Deploy Status: ${{ needs.deploy.outputs.deployment_status }}
            - URL: ${{ needs.deploy.outputs.deployment_url }}
            
            **Independent Container Architecture:**
            - SafeWork PostgreSQL (Port 4546): Database service
            - SafeWork Redis (Port 4547): Cache service  
            - SafeWork App (Port 4545): Flask application
            
            **MCP-Enhanced Analysis Request:**
            Use ThinkMCP for complex reasoning, ShrimpMCP for task planning, and SerenaMCP for code analysis:
            
            1. **ThinkMCP Analysis**: Deep reasoning on deployment success/failure patterns
            2. **ShrimpMCP Planning**: Create optimization tasks and improvement roadmap  
            3. **SerenaMCP Code Review**: Analyze codebase health and architecture compliance
            4. **Performance Optimization**: Container resource usage and bottleneck analysis
            5. **Future Recommendations**: Next deployment cycle improvements
            
            **SafeWork Specific Context:**
            - Flask 3.0+ Industrial Safety Management System
            - 001/002 Health Survey Forms with Korean localization
            - Independent container architecture (no docker-compose)
            - Watchtower auto-deployment integration
            - Korean KST timezone support
            - Bootstrap 4.6 responsive UI
            
            Provide comprehensive analysis and actionable recommendations in Korean.
          claude_args: |
            mcp_servers: ["shrimp-task-manager", "sequential-thinking", "serena"]
            execution_mode: "automation"
            max_iterations: 3