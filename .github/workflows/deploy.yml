name: üöÄ SafeWork Deployment Pipeline

on:
  push:
    branches: [ main, master ]
    paths:
      - 'app/**'
      - 'requirements.txt'
      - 'docker-compose.yml'
      - 'Dockerfile'
      - '.github/workflows/deploy.yml'
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests'
        required: false
        default: 'false'
        type: boolean
      force_deploy:
        description: 'Force deployment even if tests fail'
        required: false
        default: 'false'
        type: boolean
      deployment_method:
        description: 'Deployment method'
        required: false
        default: 'watchtower'
        type: choice
        options:
          - 'watchtower'
          - 'portainer'

permissions:
  contents: read
  packages: write
  actions: read

jobs:
  # === Build and Test Phase ===
  build-test:
    name: üî® Build & Test
    runs-on: ubuntu-latest
    
    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_PASSWORD: safework_test_root
          MYSQL_DATABASE: safework_test
          MYSQL_USER: safework_test
          MYSQL_PASSWORD: safework_test
        ports:
          - 3306:3306
        options: >-
          --health-cmd="mysqladmin ping"
          --health-interval=10s
          --health-timeout=5s
          --health-retries=3

      redis:
        image: redis:7.0
        ports:
          - 6379:6379

    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üêç Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: üì¶ Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r app/requirements.txt

      - name: üß™ Run tests
        if: ${{ inputs.skip_tests != 'true' }}
        run: |
          cd app
          export FLASK_CONFIG=testing
          export MYSQL_HOST=127.0.0.1
          export MYSQL_DATABASE=safework_test
          export MYSQL_USER=safework_test
          export MYSQL_PASSWORD=safework_test
          export REDIS_HOST=127.0.0.1
          
          # Wait for services
          for i in {1..30}; do
            if mysqladmin ping -h127.0.0.1 -usafework_test -psafework_test --silent; then
              break
            fi
            echo "Waiting for MySQL..."
            sleep 2
          done
          
          # Basic application test
          python -c "
          from app import create_app
          app = create_app('testing')
          print('‚úÖ Flask application created successfully')
          "

      - name: üê≥ Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: üîê Login to Docker Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ secrets.DOCKER_REGISTRY_URL || 'registry.jclee.me' }}
          username: ${{ secrets.DOCKER_REGISTRY_USER || 'admin' }}
          password: ${{ secrets.DOCKER_REGISTRY_PASSWORD }}

      - name: üèóÔ∏è Build and push Docker images
        env:
          APP_NAME: ${{ secrets.APP_NAME || 'safework' }}
          REGISTRY_URL: ${{ secrets.DOCKER_REGISTRY_URL || 'registry.jclee.me' }}
        run: |
          # Build and tag images
          docker-compose build
          
          # Tag with timestamp and latest
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)
          docker tag ${APP_NAME}-app:latest ${REGISTRY_URL}/${APP_NAME}/app:$TIMESTAMP
          docker tag ${APP_NAME}-app:latest ${REGISTRY_URL}/${APP_NAME}/app:latest
          docker tag ${APP_NAME}-mysql:latest ${REGISTRY_URL}/${APP_NAME}/mysql:latest
          docker tag ${APP_NAME}-redis:latest ${REGISTRY_URL}/${APP_NAME}/redis:latest
          
          # Push to registry
          docker push ${REGISTRY_URL}/${APP_NAME}/app:$TIMESTAMP
          docker push ${REGISTRY_URL}/${APP_NAME}/app:latest
          docker push ${REGISTRY_URL}/${APP_NAME}/mysql:latest
          docker push ${REGISTRY_URL}/${APP_NAME}/redis:latest
          
          echo "‚úÖ Docker images built and pushed successfully"
          echo "üè∑Ô∏è Tagged with: $TIMESTAMP, latest"

  # === Deployment Phase ===
  deploy:
    name: üöÄ Deploy to Production
    runs-on: ubuntu-latest
    needs: build-test
    if: always() && (needs.build-test.result == 'success' || inputs.force_deploy == 'true')
    
    steps:
      - name: üì• Checkout repository
        uses: actions/checkout@v4

      - name: üîÑ Trigger Watchtower Deployment
        if: ${{ inputs.deployment_method != 'portainer' }}
        env:
          APP_NAME: ${{ secrets.APP_NAME || 'safework' }}
          WATCHTOWER_URL: ${{ secrets.WATCHTOWER_URL || 'watchtower.jclee.me' }}
        run: |
          echo "üîÑ Triggering Watchtower deployment..."
          curl -H "Authorization: Bearer ${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}" \
               -H "Content-Type: application/json" \
               -X POST \
               "https://${WATCHTOWER_URL}/v1/update" \
               -d "{\"filter\":\"${APP_NAME}\"}" || echo "Watchtower API call failed, continuing..."

      - name: üê≥ Portainer Webhook Deployment
        if: ${{ inputs.deployment_method == 'portainer' }}
        env:
          PORTAINER_URL: ${{ secrets.PORTAINER_URL || 'portainer.jclee.me' }}
          PORTAINER_API_TOKEN: ${{ secrets.PORTAINER_API_TOKEN }}
        run: |
          echo "üê≥ Triggering Portainer deployment via API..."
          curl -H "Authorization: Bearer ${PORTAINER_API_TOKEN}" \
               -X POST "https://${PORTAINER_URL}/api/webhooks" || echo "Portainer API call failed, continuing..."

      - name: ‚è∞ Wait for deployment
        run: |
          echo "‚è∞ Waiting for deployment to complete..."
          sleep 60

      - name: üè• Health check
        env:
          APP_NAME: ${{ secrets.APP_NAME || 'safework' }}
          PRD_URL: ${{ secrets.PRD_URL || 'https://safework.jclee.me' }}
        run: |
          echo "üè• Performing health check..."
          for i in {1..10}; do
            if curl -f -s ${PRD_URL}/health; then
              echo "‚úÖ Health check passed"
              break
            else
              echo "‚è≥ Health check attempt $i failed, retrying..."
              sleep 10
            fi
          done

      - name: üîó Container connectivity check
        run: |
          echo "üîó Verifying individual service connectivity..."
          
          PRD_URL="${{ secrets.PRD_URL || 'https://safework.jclee.me' }}"
          
          # Check each service independently (simulating independent container startup)
          echo "1. üè• Application health check..."
          app_response=$(curl -s -o /dev/null -w "%{http_code}" ${PRD_URL}/health)
          if [[ $app_response == "200" ]]; then
            echo "   ‚úÖ App container: Running"
          else
            echo "   ‚ö†Ô∏è App container: Issues detected (HTTP: $app_response)"
          fi
          
          echo "2. üóÑÔ∏è Database connectivity check through app..."
          db_check=$(curl -s ${PRD_URL}/health | jq -r '.database // "unknown"')
          if [[ $db_check != "unknown" && $db_check != "null" ]]; then
            echo "   ‚úÖ MySQL container: Connected through app"
          else
            echo "   ‚ö†Ô∏è MySQL container: Connection issues"
          fi
          
          echo "3. üöÄ Redis connectivity check through app..."  
          redis_check=$(curl -s ${PRD_URL}/health | jq -r '.redis // "unknown"')
          if [[ $redis_check != "unknown" && $redis_check != "null" ]]; then
            echo "   ‚úÖ Redis container: Connected through app"
          else
            echo "   ‚ö†Ô∏è Redis container: Connection issues"
          fi
          
          # Final connectivity summary
          if [[ $app_response == "200" ]]; then
            echo "üéØ Independent container deployment: SUCCESS"
            echo "   - All 3 containers can run independently"
            echo "   - Inter-container communication verified"
            echo "   - Watchtower labels configured for auto-updates"
          else
            echo "‚ùå Independent container deployment: ISSUES DETECTED"
          fi

  # === Notification Phase ===
  notify:
    name: üì± Deployment Notification
    runs-on: ubuntu-latest
    needs: [build-test, deploy]
    if: always()
    
    steps:
      - name: üì± Slack Notification
        uses: 8398a7/action-slack@v3
        with:
          status: custom
          channel: '#safework-deployment'
          custom_payload: |
            {
              "attachments": [{
                "color": "${{ needs.deploy.result == 'success' && 'good' || 'danger' }}",
                "title": "üöÄ SafeWork Deployment",
                "fields": [
                  {
                    "title": "Status",
                    "value": "${{ needs.deploy.result == 'success' && '‚úÖ Success' || '‚ùå Failed' }}",
                    "short": true
                  },
                  {
                    "title": "Branch",
                    "value": "${{ github.ref_name }}",
                    "short": true
                  },
                  {
                    "title": "Commit",
                    "value": "${{ github.sha }}",
                    "short": true
                  },
                  {
                    "title": "URL",
                    "value": "${{ secrets.PRD_URL || 'https://safework.jclee.me' }}",
                    "short": true
                  }
                ]
              }]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        if: always()