name: 🚀 SafeWork Production Deployment

# Prevent concurrent deployments
concurrency:
  group: production-deploy-${{ github.ref_name }}
  cancel-in-progress: false

on:
  push:
    branches: [master]
    paths:
      - 'app/**'
      - 'postgres/**'
      - 'redis/**'
      - 'Dockerfile*'
      - '.github/workflows/deploy-optimized.yml'

  workflow_dispatch:
    inputs:
      force_rebuild:
        description: 'Force rebuild all containers'
        required: false
        default: false
        type: boolean

env:
  APP_NAME: safework
  REGISTRY_HOST: registry.jclee.me
  REGISTRY_USER: admin
  REGISTRY_PASSWORD: ${{ secrets.REGISTRY_PASSWORD }}
  TZ: Asia/Seoul

  # Application URLs
  PRD_URL: https://safework.jclee.me
  DEV_URL: https://safework-dev.jclee.me

  # Infrastructure APIs
  PORTAINER_URL: https://portainer.jclee.me
  PORTAINER_API_KEY: ${{ secrets.PORTAINER_API_KEY }}
  WATCHTOWER_URL: https://watchtower.jclee.me
  WATCHTOWER_HTTP_API_TOKEN: ${{ secrets.WATCHTOWER_HTTP_API_TOKEN }}

  # Database Configuration
  POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
  POSTGRES_DB: safework_db
  POSTGRES_USER: safework
  SECRET_KEY: ${{ secrets.SECRET_KEY }}

permissions:
  contents: write
  actions: write
  packages: write
  security-events: write
  deployments: write

jobs:
  # Phase 1: Build Independent Containers
  build-containers:
    name: 🔨 Build Independent Containers
    runs-on: ubuntu-latest
    outputs:
      app_tag: ${{ steps.app_meta.outputs.tags }}
      postgres_tag: ${{ steps.postgres_meta.outputs.tags }}
      redis_tag: ${{ steps.redis_meta.outputs.tags }}

    steps:
      - name: 📂 Checkout Repository
        uses: actions/checkout@v4

      - name: 🔐 Login to Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_HOST }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: 🏷️ Generate Container Metadata
        id: app_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/app
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest

      - name: 🏷️ Generate Postgres Metadata
        id: postgres_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/postgres
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest

      - name: 🏷️ Generate Redis Metadata
        id: redis_meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/redis
          tags: |
            type=ref,event=branch
            type=sha,prefix={{branch}}-
            type=raw,value=latest

      - name: 🐳 Build and Push App Container
        uses: docker/build-push-action@v5
        with:
          context: ./app
          file: ./app/Dockerfile
          push: true
          tags: ${{ steps.app_meta.outputs.tags }}
          labels: |
            ${{ steps.app_meta.outputs.labels }}
            com.centurylinklabs.watchtower.enable=true
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            VCS_REF=${{ github.sha }}
            VCS_URL=${{ github.server_url }}/${{ github.repository }}

      - name: 🐳 Build and Push Postgres Container
        uses: docker/build-push-action@v5
        with:
          context: ./postgres
          file: ./postgres/Dockerfile
          push: true
          tags: ${{ steps.postgres_meta.outputs.tags }}
          labels: |
            ${{ steps.postgres_meta.outputs.labels }}
            com.centurylinklabs.watchtower.enable=true

      - name: 🐳 Build and Push Redis Container
        uses: docker/build-push-action@v5
        with:
          context: ./redis
          file: ./redis/Dockerfile
          push: true
          tags: ${{ steps.redis_meta.outputs.tags }}
          labels: |
            ${{ steps.redis_meta.outputs.labels }}
            com.centurylinklabs.watchtower.enable=true

  # Phase 2: Test Container Connectivity
  test-connectivity:
    name: 🔗 Test Independent Container Connectivity
    runs-on: ubuntu-latest
    needs: build-containers

    steps:
      - name: 🔐 Login to Registry for Testing
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY_HOST }}
          username: ${{ env.REGISTRY_USER }}
          password: ${{ env.REGISTRY_PASSWORD }}

      - name: 🐳 Create Test Network
        run: docker network create safework-test-network

      - name: 🟢 Start PostgreSQL Container
        run: |
          docker run -d --name test-postgres \
            --network safework-test-network \
            -e POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }} \
            -e POSTGRES_DB=${{ env.POSTGRES_DB }} \
            -e POSTGRES_USER=${{ env.POSTGRES_USER }} \
            ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/postgres:latest

      - name: 🔴 Start Redis Container
        run: |
          docker run -d --name test-redis \
            --network safework-test-network \
            ${{ env.REGISTRY_HOST }}/${{ env.APP_NAME }}/redis:latest

      - name: ⏱️ Wait for Database Startup
        run: sleep 30

      - name: 🧪 Test PostgreSQL Connectivity
        run: |
          docker run --rm --network safework-test-network \
            postgres:15 pg_isready -h test-postgres -p 5432 -U ${{ env.POSTGRES_USER }}

      - name: 🧪 Test Redis Connectivity
        run: |
          docker run --rm --network safework-test-network \
            redis:7 redis-cli -h test-redis ping

      - name: 🧹 Cleanup Test Environment
        if: always()
        run: |
          docker stop test-postgres test-redis || true
          docker rm test-postgres test-redis || true
          docker network rm safework-test-network || true

  # Phase 3: Deploy via Watchtower
  deploy-production:
    name: 🚀 Deploy to Production
    runs-on: ubuntu-latest
    needs: [build-containers, test-connectivity]
    environment: production

    steps:
      - name: 🔔 Trigger Watchtower Auto-Deploy
        run: |
          curl -H "Authorization: Bearer ${{ env.WATCHTOWER_HTTP_API_TOKEN }}" \
               -X POST \
               "${{ env.WATCHTOWER_URL }}/v1/update"

      - name: ⏱️ Wait for Deployment
        run: sleep 60

      - name: 🏥 Health Check - Production
        run: |
          for i in {1..10}; do
            if curl -f "${{ env.PRD_URL }}/health"; then
              echo "✅ Production health check passed"
              exit 0
            fi
            echo "⏳ Waiting for production... ($i/10)"
            sleep 30
          done
          echo "❌ Production health check failed"
          exit 1

      - name: 📊 Verify Database Connectivity
        run: |
          # Test survey submission to verify database schema fix
          response=$(curl -s -X POST "${{ env.PRD_URL }}/survey/api/submit" \
            -H "Content-Type: application/json" \
            -d '{
              "form_type": "001",
              "name": "Production Test",
              "age": 30,
              "gender": "Male",
              "years_of_service": 5,
              "employee_number": "TEST001",
              "department": "QA",
              "position": "Tester",
              "employee_id": "QA001",
              "work_years": 3,
              "work_months": 6,
              "data": {"has_symptoms": false}
            }')

          if echo "$response" | grep -q '"success": true'; then
            echo "✅ Database connectivity and schema verified"
          else
            echo "❌ Database connectivity test failed: $response"
            exit 1
          fi

  # Phase 4: Container Health Monitoring
  monitor-deployment:
    name: 📊 Monitor Container Health
    runs-on: ubuntu-latest
    needs: deploy-production
    if: always()

    steps:
      - name: 📋 Advanced Container Health Check via Portainer API
        run: |
          if [ -n "${{ env.PORTAINER_API_KEY }}" ]; then
            echo "🔍 Advanced SafeWork Container Health Analysis..."

            # Function to get container info from multiple endpoints
            get_containers_info() {
              local endpoint=$1
              echo "Checking endpoint $endpoint..."
              curl -s -H "X-API-Key: ${{ env.PORTAINER_API_KEY }}" \
                "${{ env.PORTAINER_URL }}/api/endpoints/$endpoint/docker/containers/json?all=true" 2>/dev/null || echo "[]"
            }

            # Check multiple Portainer endpoints (1, 2, 3 - common endpoint IDs)
            SAFEWORK_CONTAINERS=""
            for endpoint in 1 2 3; do
              containers_json=$(get_containers_info "$endpoint")
              safework_containers=$(echo "$containers_json" | jq -r '.[] | select(.Names[]? | test("safework|SafeWork"; "i")) | @base64' 2>/dev/null || echo "")

              if [ -n "$safework_containers" ]; then
                echo "✅ Found SafeWork containers on endpoint $endpoint"
                ENDPOINT_FOUND="$endpoint"
                break
              fi
            done

            if [ -z "$safework_containers" ]; then
              echo "❌ No SafeWork containers found on any endpoint"
              echo "🔍 Listing all available containers for debugging:"
              for endpoint in 1 2 3; do
                containers_json=$(get_containers_info "$endpoint")
                if [ "$containers_json" != "[]" ]; then
                  echo "=== Endpoint $endpoint ==="
                  echo "$containers_json" | jq -r '.[]?.Names[]? // "unnamed"' 2>/dev/null | head -10
                fi
              done
              exit 1
            fi

            echo "📊 SafeWork Container Detailed Analysis (Endpoint: $ENDPOINT_FOUND):"
            echo "=================================================="

            # Analyze each SafeWork container
            echo "$safework_containers" | while IFS= read -r container_base64; do
              if [ -n "$container_base64" ]; then
                container_info=$(echo "$container_base64" | base64 -d)

                container_name=$(echo "$container_info" | jq -r '.Names[0] // "unknown"')
                container_id=$(echo "$container_info" | jq -r '.Id // "unknown"')
                container_state=$(echo "$container_info" | jq -r '.State // "unknown"')
                container_status=$(echo "$container_info" | jq -r '.Status // "unknown"')
                container_image=$(echo "$container_info" | jq -r '.Image // "unknown"')
                created_time=$(echo "$container_info" | jq -r '.Created // 0')

                echo "🐳 Container: $container_name"
                echo "   ID: ${container_id:0:12}"
                echo "   State: $container_state"
                echo "   Status: $container_status"
                echo "   Image: $container_image"

                # Convert created time to human readable
                if [ "$created_time" != "0" ] && [ "$created_time" != "null" ]; then
                  created_date=$(date -d "@$created_time" '+%Y-%m-%d %H:%M:%S' 2>/dev/null || echo "unknown")
                  echo "   Created: $created_date"
                fi

                # Check if container is recently updated (within last 10 minutes - Watchtower update indicator)
                current_time=$(date +%s)
                if [ "$created_time" != "0" ] && [ "$created_time" != "null" ]; then
                  time_diff=$((current_time - created_time))
                  if [ $time_diff -le 600 ]; then
                    echo "   🔄 RECENTLY UPDATED (${time_diff}s ago) - Watchtower likely updated this container"
                  fi
                fi

                # Check container health if available
                health_status=$(echo "$container_info" | jq -r '.State.Health.Status // "no-healthcheck"')
                if [ "$health_status" != "no-healthcheck" ]; then
                  echo "   Health: $health_status"
                fi

                # Get detailed container stats
                echo "   📈 Getting container stats..."
                stats=$(curl -s -H "X-API-Key: ${{ env.PORTAINER_API_KEY }}" \
                  "${{ env.PORTAINER_URL }}/api/endpoints/$ENDPOINT_FOUND/docker/containers/${container_id}/stats?stream=false" 2>/dev/null || echo "{}")

                if [ "$stats" != "{}" ]; then
                  cpu_usage=$(echo "$stats" | jq -r '.cpu_stats.cpu_usage.total_usage // 0' 2>/dev/null)
                  memory_usage=$(echo "$stats" | jq -r '.memory_stats.usage // 0' 2>/dev/null)
                  memory_limit=$(echo "$stats" | jq -r '.memory_stats.limit // 0' 2>/dev/null)

                  if [ "$memory_usage" != "0" ] && [ "$memory_limit" != "0" ]; then
                    memory_percent=$(echo "scale=1; $memory_usage * 100 / $memory_limit" | bc -l 2>/dev/null || echo "0")
                    echo "   Memory: ${memory_percent}%"
                  fi
                fi

                echo "   ----------------------------------"
              fi
            done

            # Summary
            total_containers=$(echo "$safework_containers" | wc -l)
            running_containers=$(containers_json=$(get_containers_info "$ENDPOINT_FOUND"); echo "$containers_json" | jq -r '.[] | select(.Names[]? | test("safework|SafeWork"; "i")) | select(.State == "running") | .Names[0]' | wc -l)

            echo "📋 Summary:"
            echo "   Total SafeWork containers: $total_containers"
            echo "   Running containers: $running_containers"
            echo "   Portainer endpoint: $ENDPOINT_FOUND"

            if [ "$running_containers" -eq "$total_containers" ] && [ "$total_containers" -gt 0 ]; then
              echo "✅ All SafeWork containers are running healthy"
            else
              echo "⚠️ Some SafeWork containers may have issues"
            fi

          else
            echo "⚠️ Portainer API key not configured - skipping detailed container analysis"
          fi

      - name: 📈 Performance Metrics
        run: |
          echo "🎯 Production Performance Metrics:"

          # Response time test
          start_time=$(date +%s%N)
          curl -s "${{ env.PRD_URL }}" > /dev/null
          end_time=$(date +%s%N)
          response_time=$(( (end_time - start_time) / 1000000 ))

          echo "⚡ Homepage response time: ${response_time}ms"

          if [ $response_time -lt 3000 ]; then
            echo "✅ Performance: Excellent"
          elif [ $response_time -lt 5000 ]; then
            echo "⚠️ Performance: Good"
          else
            echo "❌ Performance: Needs optimization"
          fi

  # Phase 5: Rollback on Failure
  rollback-on-failure:
    name: 🔄 Emergency Rollback
    runs-on: ubuntu-latest
    needs: [deploy-production, monitor-deployment]
    if: failure()

    steps:
      - name: 🚨 Rollback Deployment
        run: |
          echo "🔄 Initiating emergency rollback..."

          # Stop current containers
          curl -H "Authorization: Bearer ${{ env.WATCHTOWER_HTTP_API_TOKEN }}" \
               -X POST \
               "${{ env.WATCHTOWER_URL }}/v1/stop"

          # Wait and restart with previous stable version
          sleep 30

          curl -H "Authorization: Bearer ${{ env.WATCHTOWER_HTTP_API_TOKEN }}" \
               -X POST \
               "${{ env.WATCHTOWER_URL }}/v1/update?rollback=true"

      - name: 🆘 Create Emergency Issue
        uses: actions/github-script@v7
        with:
          script: |
            github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: '🚨 EMERGENCY: Production Deployment Failed - Auto-Rollback Initiated',
              body: `
              ## 🚨 Critical Deployment Failure

              **Deployment Details:**
              - Commit: ${{ github.sha }}
              - Branch: ${{ github.ref_name }}
              - Workflow: ${{ github.workflow }}
              - Run ID: ${{ github.run_id }}

              **Actions Taken:**
              - ✅ Emergency rollback initiated
              - ✅ Previous stable version restored
              - ✅ Monitoring activated

              **Required Actions:**
              - [ ] Investigate deployment failure logs
              - [ ] Fix identified issues
              - [ ] Test in development environment
              - [ ] Re-deploy with fixes

              **Monitoring:**
              - Production URL: ${{ env.PRD_URL }}
              - Health Check: ${{ env.PRD_URL }}/health

              @qws941 Please investigate immediately.
              `,
              labels: ['critical', 'deployment', 'auto-generated', 'emergency']
            })

  # Phase 6: Success Notification
  notify-success:
    name: ✅ Deployment Success Notification
    runs-on: ubuntu-latest
    needs: [deploy-production, monitor-deployment]
    if: success()

    steps:
      - name: 🎉 Deployment Success
        run: |
          echo "🎉 Deployment completed successfully!"
          echo "🌐 Production URL: ${{ env.PRD_URL }}"
          echo "🏥 Health Check: ${{ env.PRD_URL }}/health"
          echo "📊 Container Status: All services running"
          echo "✅ Database Schema: Fixed and verified"