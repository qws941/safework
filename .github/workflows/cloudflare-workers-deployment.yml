# ==============================================================================
# Gemini-Powered Cloudflare Workers CI/CD Pipeline
# ==============================================================================
# This workflow integrates Gemini AI to enhance the development process:
# 1. AI Code Review: On every PR, Gemini reviews code changes for quality.
# 2. Build & Test: Ensures code integrity with linting, type checks, and tests.
# 3. Deploy to Staging: Automatically deploys to a staging environment.
# 4. Deploy to Production: Deploys to production after manual approval.
# 5. AI Release Notes: Automatically generates and publishes release notes
#                       after a successful production deployment.
# ==============================================================================

name: Gemini-Powered Cloudflare Workers CI/CD

on:
  push:
    branches: [master, staging]
    paths:
      - 'workers/**'
  pull_request:
    branches: [master, staging]
    paths:
      - 'workers/**'
  workflow_dispatch:

# Grant permissions for AI review comments and release creation
permissions:
  contents: write
  pull-requests: write

env:
  CLOUDFLARE_API_TOKEN: ${{ secrets.CLOUDFLARE_API_TOKEN }}
  CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
  NODE_VERSION: '20'

jobs:
  # ============================================
  # 1. AI Code Review Job (on Pull Requests)
  # ============================================
  ai-code-review:
    name: 'ü§ñ AI Code Review'
    if: github.event_name == 'pull_request'
    runs-on: ubuntu-latest
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: üîç Get Changed Files
        id: changed-files
        uses: tj-actions/changed-files@v41
        with:
          files: workers/**

      - name: ü§ñ Run Gemini Code Review
        if: steps.changed-files.outputs.any_changed == 'true'
        uses: actions/github-script@v6
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { repo, issue: { number: issue_number } } = github.context;
            const changedFiles = `${{ steps.changed-files.outputs.all_changed_files }}`.split(' ').join('\n');
            const diff_url = `${{ github.event.pull_request.diff_url }}`;

            const response = await fetch(diff_url);
            const diff = await response.text();

            if (diff.length > 10000) {
              console.log("Diff is too large, skipping AI review.");
              return;
            }

            const geminiApiKey = "${{ secrets.GEMINI_API_KEY }}";
            if (!geminiApiKey) {
              console.log("GEMINI_API_KEY secret not found, skipping review.");
              return;
            }

            const prompt = `
              As a senior software engineer, please review the following code changes (git diff format) for the files listed below.
              Focus on potential bugs, performance issues, security vulnerabilities, and adherence to best practices.
              Provide specific, actionable feedback. If there are no issues, simply state "No issues found."

              Changed Files:
              ${changedFiles}

              Git Diff:
              \`\`\`diff
              ${diff}
              \`\`\`
            `;

            const geminiApiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=${geminiApiKey}`;
            const geminiResponse = await fetch(geminiApiUrl, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ contents: [{ parts: [{ text: prompt }] }] })
            });

            const geminiData = await geminiResponse.json();
            const review = geminiData.candidates[0].content.parts[0].text;

            await github.rest.issues.createComment({
              owner: repo.owner,
              repo: repo.repo,
              issue_number,
              body: `### ü§ñ Gemini AI Code Review\n\n${review}`
            });

  # ============================================
  # 2. Build and Test Job
  # ============================================
  build-and-test:
    name: 'üèóÔ∏è Build & Test'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    defaults: { run: { working-directory: ./workers } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'workers/package-lock.json'
      - run: npm ci
      - run: npm run lint
      - run: npm run type-check
      - run: npm run test

  # ============================================
  # 3. Deploy to Staging Job
  # ============================================
  deploy-staging:
    name: 'üöÄ Deploy to Staging'
    needs: build-and-test
    if: github.ref == 'refs/heads/staging' && github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    defaults: { run: { working-directory: ./workers } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'workers/package-lock.json'
      - run: npm ci
      - name: üöÄ Deploy to Staging (CF Dev Env)
        run: npx wrangler deploy --env development

  # ============================================
  # 4. Deploy to Production Job
  # ============================================
  deploy-production:
    name: 'üöÄ Deploy to Production'
    needs: build-and-test
    if: github.ref == 'refs/heads/master' && github.event_name == 'push'
    runs-on: ubuntu-latest
    timeout-minutes: 15
    environment: { name: production, url: https://safework.jclee.me }
    defaults: { run: { working-directory: ./workers } }
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 } # Required to get commit history for release notes
      - uses: actions/setup-node@v4
        with:
          node-version: ${{ env.NODE_VERSION }}
          cache: 'npm'
          cache-dependency-path: 'workers/package-lock.json'
      - run: npm ci
      - name: üöÄ Deploy to Production
        run: npx wrangler deploy --env production
      - name: üîç Verify Production Deployment
        run: |
          sleep 15
          health_status=$(curl -s -o /dev/null -w "%{http_code}" https://safework.jclee.me/api/health)
          if [ "$health_status" -ne 200 ]; then
            echo "‚ùå Health check FAILED with status $health_status."
            exit 1
          fi
          echo "‚úÖ Health check passed with status $health_status."

      # ============================================
      # 5. AI Release Notes Generation
      # ============================================
      - name: üìö Get Commit History
        id: git-log
        run: |
          # Get the latest tag, or the first commit if no tags exist
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || git rev-list --max-parents=0 HEAD)
          echo "Latest tag: $LATEST_TAG"
          # Get commit messages from the latest tag to HEAD
          COMMIT_MESSAGES=$(git log $LATEST_TAG..HEAD --pretty=format:"- %s")
          # Make the multiline string available to next steps
          echo "commits<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMIT_MESSAGES" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: ü§ñ Generate Release Notes with Gemini
        id: gemini-release-notes
        if: steps.git-log.outputs.commits != ''
        run: |
          gemini_api_key="${{ secrets.GEMINI_API_KEY }}"
          if [ -z "$gemini_api_key" ]; then
            echo "GEMINI_API_KEY not found, using plain commit log for release notes."
            echo "notes<<EOF" >> $GITHUB_OUTPUT
            echo "${{ steps.git-log.outputs.commits }}" >> $GITHUB_OUTPUT
            echo "EOF" >> $GITHUB_OUTPUT
            exit 0
          fi

          prompt="Based on the following commit messages, create a concise and user-friendly summary for a release note. Group related changes under headings like '‚ú® New Features', 'üêõ Bug Fixes', and 'üî® Improvements'.\n\nCommits:\n${{ steps.git-log.outputs.commits }}"

          # Using a heredoc for the JSON payload
          json_payload=$(cat <<EOF
          {
            "contents": [{
              "parts": [{
                "text": "$prompt"
              }]
            }]
          }
          EOF
          )

          response=$(curl -s -X POST "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash-latest:generateContent?key=$gemini_api_key" \
            -H "Content-Type: application/json" \
            -d "$json_payload")

          release_notes=$(echo "$response" | jq -r '.candidates[0].content.parts[0].text')
          echo "notes<<EOF" >> $GITHUB_OUTPUT
          echo "$release_notes" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: üì¶ Create GitHub Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          TAG_NAME="release-$(date +%Y-%m-%d-%H%M%S)"
          RELEASE_NOTES="${{ steps.gemini-release-notes.outputs.notes || steps.git-log.outputs.commits }}"
          gh release create "$TAG_NAME" --title "Release $TAG_NAME" --notes "$RELEASE_NOTES"
          echo "‚úÖ Created GitHub Release: $TAG_NAME"
