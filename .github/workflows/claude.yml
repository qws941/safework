name: Claude Code

on:
  issue_comment:
    types: [created]
  issues:
    types: [opened]
  pull_request:
    types: [opened, synchronize, reopened]
  workflow_dispatch:

jobs:
  claude:
    if: |
      github.event_name == 'workflow_dispatch' ||
      (github.event_name == 'issue_comment' && contains(github.event.comment.body, '@claude')) ||
      (github.event_name == 'issues' && github.event.action == 'opened') ||
      (github.event_name == 'pull_request' && contains(fromJSON('["opened", "synchronize", "reopened"]'), github.event.action))
    runs-on: ubuntu-latest
    timeout-minutes: 30
    permissions:
      contents: write
      issues: write
      pull-requests: write
      actions: read
      checks: read
      statuses: read
      deployments: read
      packages: read
      id-token: write
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Enhanced Claude Code Assistant  
        uses: anthropics/claude-code-action@v1
        with:
          claude_code_oauth_token: ${{ secrets.CLAUDE_CODE_OAUTH_TOKEN }}
          use_sticky_comment: true
          prompt: |
            당신은 SafeWork 프로젝트의 **시니어 풀스택 개발자**입니다.

            ## 🏗️ 프로젝트 아키텍처
            **SafeWork**: 산업 안전 보건 관리 시스템 (Flask 3.0+)
            - **백엔드**: Python Flask, SQLAlchemy 2.0, Redis 5.0  
            - **데이터베이스**: MySQL 8.0 (UTF8MB4, 트랜잭션 관리)
            - **프론트엔드**: Bootstrap 4.6, jQuery, Font Awesome
            - **핵심 기능**: 근골격계 설문조사, 건강검진, 문서관리, 관리자 패널

            ## 📋 개발 원칙 (필수 준수)
            1. **한국어 소통**: 모든 댓글과 커밋 메시지는 한국어
            2. **Flask 패턴 준수**: 블루프린트 구조, 팩토리 패턴 유지
            3. **데이터베이스 무결성**: 
               - 트랜잭션 사용 (`db.session.commit()`, `rollback()`)
               - 마이그레이션 생성 시 MySQL 8.0 호환성 확인
               - 한국 시간대(KST) 일관성: `kst_now()` 함수 사용
            4. **보안 강화**: 
               - CSRF 토큰 필수
               - SQL 인젝션 방어
               - 입력 데이터 검증 및 사니타이징
            5. **성능 최적화**: 
               - Redis 캐싱 활용
               - 데이터베이스 인덱싱
               - 쿼리 최적화

            ## 🔧 코딩 컨벤션
            ```python
            # ✅ 올바른 패턴
            @login_required
            def create_survey():
                try:
                    # 비즈니스 로직
                    db.session.commit()
                    flash('설문이 성공적으로 생성되었습니다.', 'success')
                except Exception as e:
                    db.session.rollback()
                    flash(f'오류가 발생했습니다: {str(e)}', 'error')
                    app.logger.error(f"Survey creation error: {e}")
            ```

            ## 🎯 이슈 해결 프로세스
            ### 1단계: 분석
            - 이슈 내용 정확히 파악
            - 관련 파일들 식별 (`app/routes/`, `app/models.py`, `app/templates/`)
            - 현재 구현 상태 확인

            ### 2단계: 구현
            - 기존 코드 패턴 유지
            - 단계별 변경사항 적용
            - 에러 처리 및 로깅 추가

            ### 3단계: 검증
            - 코드 리뷰 및 테스트
            - 마이그레이션 필요 시 생성
            - 의미있는 커밋 메시지 작성

            ### 4단계: 완료
            - 변경사항 요약 댓글
            - **이슈 자동 닫기** (중요!)

            ## 📁 주요 파일 구조
            ```
            app/
            ├── app.py              # 메인 애플리케이션
            ├── models.py           # 핵심 모델 (User, Survey)
            ├── models_safework.py  # SafeWork 전용 모델
            ├── routes/            # 블루프린트 라우터
            │   ├── survey.py      # 설문조사 (001/002)
            │   ├── admin.py       # 관리자 패널
            │   └── auth.py        # 인증
            └── templates/         # Jinja2 템플릿
            ```

            ## ⚡ 작업 완료 체크리스트
            - [ ] 기능 구현 완료
            - [ ] 에러 처리 추가
            - [ ] 테스트 실행 (가능한 경우)
            - [ ] 커밋 메시지 작성 ("feat:", "fix:", "refactor:" 등)
            - [ ] 이슈에 완료 댓글 작성
            - [ ] **이슈 상태를 'closed'로 변경**

            작업을 시작하세요! 🚀
          claude_args: |
            --max-turns 30

      - name: Advanced Auto PR and Merge
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const issueNumber = context.payload.issue?.number;
            const issueTitle = context.payload.issue?.title || '자동 수정';
            
            console.log(`🚀 고도화된 자동 PR/병합 프로세스 시작`);
            console.log(`📋 이슈: #${issueNumber} - ${issueTitle}`);
            
            // 1. Claude 브랜치 스마트 검색 (여러 패턴 지원)
            async function findClaudeBranches() {
              const branches = await github.rest.repos.listBranches({
                owner,
                repo,
                per_page: 100
              });
              
              const today = new Date().toISOString().slice(0, 10).replace(/-/g, '');
              const patterns = [
                `claude/issue-${issueNumber}-`,
                `claude/issue-${today}`,
                `claude/`,
              ];
              
              return branches.data.filter(branch => 
                patterns.some(pattern => branch.name.includes(pattern)) &&
                branch.name !== 'master' && branch.name !== 'main'
              ).sort((a, b) => b.commit.commit.author.date.localeCompare(a.commit.commit.author.date));
            }
            
            // 2. PR 충돌 검사
            async function checkForConflicts(branchName) {
              try {
                const comparison = await github.rest.repos.compareCommits({
                  owner,
                  repo,
                  base: 'master',
                  head: branchName
                });
                
                return {
                  hasConflicts: comparison.data.status === 'diverged',
                  ahead: comparison.data.ahead_by,
                  behind: comparison.data.behind_by,
                  files: comparison.data.files?.length || 0
                };
              } catch (error) {
                console.error('⚠️ 충돌 검사 실패:', error.message);
                return { hasConflicts: false, ahead: 0, behind: 0, files: 0 };
              }
            }
            
            // 3. 기존 PR 확인
            async function checkExistingPR(branchName) {
              try {
                const prs = await github.rest.pulls.list({
                  owner,
                  repo,
                  head: `${owner}:${branchName}`,
                  state: 'open'
                });
                return prs.data[0] || null;
              } catch (error) {
                return null;
              }
            }
            
            try {
              const claudeBranches = await findClaudeBranches();
              
              if (claudeBranches.length === 0) {
                console.log(`⚠️ Claude 브랜치를 찾을 수 없습니다`);
                return;
              }
              
              const branchName = claudeBranches[0].name;
              console.log(`🔍 최신 Claude 브랜치 발견: ${branchName}`);
              
              // 기존 PR 확인
              const existingPR = await checkExistingPR(branchName);
              if (existingPR) {
                console.log(`ℹ️ 기존 PR 발견: #${existingPR.number}, 병합 시도`);
                
                // 기존 PR 병합
                try {
                  await github.rest.pulls.merge({
                    owner,
                    repo,
                    pull_number: existingPR.number,
                    commit_title: `🤖 Claude: ${issueTitle}`,
                    commit_message: `이슈 #${issueNumber} 해결\n\nClaude가 자동으로 생성한 변경사항입니다.`,
                    merge_method: 'squash'
                  });
                  
                  console.log(`✅ 기존 PR #${existingPR.number} 병합 완료`);
                } catch (mergeError) {
                  console.error(`❌ 기존 PR 병합 실패:`, mergeError.message);
                  return;
                }
              } else {
                // 충돌 검사
                const conflictCheck = await checkForConflicts(branchName);
                console.log(`📊 브랜치 상태: ${conflictCheck.files}개 파일, ${conflictCheck.ahead}개 커밋 앞섰음`);
                
                if (conflictCheck.hasConflicts) {
                  console.log(`⚠️ 충돌 감지됨, 수동 처리 필요`);
                  
                  // 충돌 알림 댓글
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: issueNumber,
                    body: `⚠️ **자동 병합 실패**: 브랜치 \\`${branchName}\\`에서 충돌이 감지되었습니다.\\n\\n**수동 처리 필요:**\\n1. [브랜치 확인](https://github.com/${owner}/${repo}/tree/${branchName})\\n2. 충돌 해결 후 수동 병합\\n3. 또는 브랜치를 삭제하고 다시 시도\\n\\n**브랜치 상태:** ${conflictCheck.files}개 파일 수정, ${conflictCheck.ahead}개 커밋`
                  });
                  return;
                }
                
                // 새 PR 생성
                const prResponse = await github.rest.pulls.create({
                  owner,
                  repo,
                  title: `🤖 Claude: ${issueTitle}`,
                  head: branchName,
                  base: 'master',
                  body: `🤖 **Claude 자동 생성 PR**\\n\\n**📋 이슈:** #${issueNumber}\\n**🌿 브랜치:** \\`${branchName}\\`\\n**⏰ 생성 시간:** ${new Date().toLocaleString('ko-KR')}\\n**📊 변경사항:** ${conflictCheck.files}개 파일, ${conflictCheck.ahead}개 커밋\\n\\n## 🔄 자동화 프로세스\\n- ✅ 충돌 검사 통과\\n- ✅ 브랜치 상태 검증 완료\\n- 🔄 자동 병합 예정\\n\\n---\\n*🤖 Generated by Enhanced Claude Code Assistant*`
                });
                
                console.log(`✅ 새 PR 생성 완료: #${prResponse.data.number}`);
                
                // PR 상태 안정화 대기
                await new Promise(resolve => setTimeout(resolve, 3000));
                
                // 자동 병합
                await github.rest.pulls.merge({
                  owner,
                  repo,
                  pull_number: prResponse.data.number,
                  commit_title: `🤖 Claude: ${issueTitle}`,
                  commit_message: `이슈 #${issueNumber} 해결\n\nClaude가 자동으로 분석하고 수정한 변경사항입니다.\n\n변경 파일: ${conflictCheck.files}개\n커밋: ${conflictCheck.ahead}개`,
                  merge_method: 'squash'
                });
                
                console.log(`✅ 자동 병합 완료`);
              }
              
              // 브랜치 정리
              await github.rest.git.deleteRef({
                owner,
                repo,
                ref: `heads/${branchName}`
              });
              
              console.log(`🗑️ 브랜치 삭제 완료: ${branchName}`);
              
              // 성공 댓글
              if (issueNumber) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: `✅ **자동 처리 완료!**\\n\\n🤖 Claude가 이슈를 성공적으로 해결했습니다.\\n- 브랜치: \\`${branchName}\\`\\n- PR 생성 및 병합 완료\\n- 브랜치 정리 완료\\n\\n변경사항이 main 브랜치에 적용되었습니다. 🎉`
                });
                
                // 이슈 자동 닫기
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  state: 'closed'
                });
                
                console.log(`🔒 이슈 #${issueNumber} 자동 닫기 완료`);
              }
              
            } catch (error) {
              console.error(`❌ 고도화된 자동 처리 실패:`, error);
              
              // 실패 시 알림
              if (issueNumber) {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: issueNumber,
                  body: `❌ **자동 처리 실패**\\n\\n오류가 발생했습니다: \\`${error.message}\\`\\n\\n**다음 단계:**\\n1. GitHub Actions 로그 확인\\n2. 수동으로 브랜치 확인 및 처리\\n3. 필요시 이슈 재할당\\n\\n*오류 시간: ${new Date().toLocaleString('ko-KR')}*`
                });
              }
            }

