name: SafeWork Auto Issue Detection & CI/CD Monitor

on:
  push:
    branches: [ master, main, develop ]
  pull_request:
    branches: [ master, main ]
  schedule:
    - cron: '*/30 * * * *'  # 30ë¶„ë§ˆë‹¤ ì‹¤í–‰
  workflow_run:
    workflows: ["Deploy", "Claude", "Review", "SafeWork Smart Notifications"]
    types: [completed]

env:
  SAFEWORK_URL: "https://safework.jclee.me"

jobs:
  auto-detect-issues:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 50

      - name: Setup Python for Analysis
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'

      - name: Install Analysis Dependencies
        run: |
          pip install requests beautifulsoup4 flask sqlalchemy pytest bandit safety

      - name: SafeWork Comprehensive Issue Detection
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const { execSync } = require('child_process');
            
            // 1. ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬
            async function checkSystemHealth() {
              console.log('ğŸ¥ SafeWork ì‹œìŠ¤í…œ í—¬ìŠ¤ ì²´í¬ ì‹œì‘...');
              
              const issues = [];
              
              try {
                // SafeWork ì•± ì ‘ì† í…ŒìŠ¤íŠ¸
                const response = await fetch('${{ env.SAFEWORK_URL }}/health', {
                  timeout: 10000
                });
                
                if (!response.ok) {
                  issues.push({
                    title: `ğŸš¨ SafeWork ì‹œìŠ¤í…œ ë‹¤ìš´ ê°ì§€`,
                    body: `SafeWork ì•±ì´ ì‘ë‹µí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                    
**ìƒíƒœ ì •ë³´:**
- URL: ${{ env.SAFEWORK_URL }}
- HTTP ìƒíƒœ: ${response.status}
- ê°ì§€ ì‹œê°„: ${new Date().toISOString()}

**ìë™ ëŒ€ì‘ í•„ìš”:**
- [ ] ì„œë²„ ìƒíƒœ í™•ì¸
- [ ] Docker ì»¨í…Œì´ë„ˆ ì¬ì‹œì‘
- [ ] ë¡œê·¸ ë¶„ì„
- [ ] DB ì—°ê²° ìƒíƒœ í™•ì¸`,
                    labels: ['P0-CRITICAL', 'component:deployment', 'automated']
                  });
                }
              } catch (error) {
                issues.push({
                  title: `ğŸ’” SafeWork ì‹œìŠ¤í…œ ì—°ê²° ì‹¤íŒ¨`,
                  body: `SafeWork ì‹œìŠ¤í…œì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
                  
**ì˜¤ë¥˜ ì •ë³´:**
- ì˜¤ë¥˜: ${error.message}
- ê°ì§€ ì‹œê°„: ${new Date().toISOString()}

**ì¦‰ì‹œ í™•ì¸ í•„ìš”:**
- [ ] ì„œë²„ ê°€ë™ ìƒíƒœ
- [ ] ë„¤íŠ¸ì›Œí¬ ì—°ê²°
- [ ] DNS ì„¤ì •
- [ ] SSL ì¸ì¦ì„œ`,
                  labels: ['P0-CRITICAL', 'component:deployment', 'automated']
                });
              }
              
              return issues;
            }
            
            // 2. CI/CD íŒŒì´í”„ë¼ì¸ ëª¨ë‹ˆí„°ë§
            async function monitorCICDPipeline() {
              console.log('ğŸ” CI/CD íŒŒì´í”„ë¼ì¸ ì‹¤íŒ¨ ê°ì§€...');
              
              const issues = [];
              
              try {
                // ìµœê·¼ ì›Œí¬í”Œë¡œ ì‹¤í–‰ ì¡°íšŒ
                const { data: runs } = await github.rest.actions.listWorkflowRunsForRepo({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  per_page: 20,
                  status: 'completed'
                });
                
                const failedRuns = runs.workflow_runs.filter(run => 
                  run.conclusion === 'failure' && 
                  new Date(run.created_at) > new Date(Date.now() - 2 * 60 * 60 * 1000) // 2ì‹œê°„ ë‚´
                );
                
                // ì‹¤íŒ¨ìœ¨ì´ 50% ì´ìƒì´ë©´ ì´ìŠˆ ìƒì„±
                if (failedRuns.length >= 3) {
                  const failuresByWorkflow = {};
                  failedRuns.forEach(run => {
                    failuresByWorkflow[run.name] = (failuresByWorkflow[run.name] || 0) + 1;
                  });
                  
                  issues.push({
                    title: `âš ï¸ CI/CD íŒŒì´í”„ë¼ì¸ ë‹¤ì¤‘ ì‹¤íŒ¨ ê°ì§€`,
                    body: `ìµœê·¼ 2ì‹œê°„ ë‚´ ë‹¤ìˆ˜ì˜ ì›Œí¬í”Œë¡œ ì‹¤íŒ¨ê°€ ê°ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.
                    
**ì‹¤íŒ¨ í˜„í™©:**
${Object.entries(failuresByWorkflow).map(([name, count]) => 
  `- ${name}: ${count}ë²ˆ ì‹¤íŒ¨`).join('\\n')}

**ì‹¤íŒ¨í•œ ì›Œí¬í”Œë¡œ:**
${failedRuns.slice(0, 5).map(run => 
  `- [${run.name}](${run.html_url}) (${new Date(run.created_at).toLocaleString()})`).join('\\n')}

**ìë™ ë¶„ì„ ë° ëŒ€ì‘ í•„ìš”**`,
                    labels: ['P1-HIGH', 'component:deployment', 'automated']
                  });
                }
                
              } catch (error) {
                console.error('CI/CD ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜:', error);
              }
              
              return issues;
            }
            
            // 3. ì½”ë“œ í’ˆì§ˆ ìë™ ë¶„ì„
            async function analyzeCodeQuality() {
              console.log('ğŸ“Š ì½”ë“œ í’ˆì§ˆ ìë™ ë¶„ì„...');
              
              const issues = [];
              
              try {
                // Python ì½”ë“œ ë³´ì•ˆ ì·¨ì•½ì  ê²€ì‚¬
                try {
                  const banditResult = execSync('bandit -r app/ -f json', { encoding: 'utf-8' });
                  const banditData = JSON.parse(banditResult);
                  
                  const highSeverityIssues = banditData.results.filter(r => 
                    r.issue_severity === 'HIGH' || r.issue_severity === 'MEDIUM'
                  );
                  
                  if (highSeverityIssues.length > 0) {
                    issues.push({
                      title: `ğŸ” ë³´ì•ˆ ì·¨ì•½ì  ìë™ ê°ì§€ (${highSeverityIssues.length}ê±´)`,
                      body: `Bandit ë³´ì•ˆ ë¶„ì„ì—ì„œ ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.
                      
**ë°œê²¬ëœ ì·¨ì•½ì :**
${highSeverityIssues.slice(0, 5).map(issue => 
  `- **${issue.test_name}** (${issue.issue_severity})
  - íŒŒì¼: ${issue.filename}:${issue.line_number}
  - ì„¤ëª…: ${issue.issue_text}`).join('\\n\\n')}

**ë³´ì•ˆ ê°•í™” í•„ìš”**`,
                      labels: ['P1-HIGH', 'type:security', 'automated']
                    });
                  }
                } catch (e) {
                  console.log('Bandit ë¶„ì„ ê±´ë„ˆë›°ê¸°:', e.message);
                }
                
                // ì˜ì¡´ì„± ì·¨ì•½ì  ê²€ì‚¬
                try {
                  const safetyResult = execSync('safety check --json', { encoding: 'utf-8' });
                  const safetyData = JSON.parse(safetyResult);
                  
                  if (safetyData.length > 0) {
                    issues.push({
                      title: `ğŸ“¦ ì˜ì¡´ì„± ì·¨ì•½ì  ìë™ ê°ì§€ (${safetyData.length}ê±´)`,
                      body: `Python íŒ¨í‚¤ì§€ ì·¨ì•½ì ì´ ë°œê²¬ë˜ì—ˆìŠµë‹ˆë‹¤.
                      
**ì·¨ì•½í•œ íŒ¨í‚¤ì§€:**
${safetyData.slice(0, 5).map(vuln => 
  `- **${vuln.package_name} ${vuln.installed_version}**
  - ì·¨ì•½ì : ${vuln.vulnerability_id}
  - ì‹¬ê°ë„: ${vuln.severity || 'Unknown'}
  - í•´ê²°: ${vuln.more_info_url}`).join('\\n\\n')}

**ì˜ì¡´ì„± ì—…ë°ì´íŠ¸ í•„ìš”**`,
                      labels: ['P2-MEDIUM', 'type:dependencies', 'automated']
                    });
                  }
                } catch (e) {
                  console.log('Safety ë¶„ì„ ê±´ë„ˆë›°ê¸°:', e.message);
                }
                
              } catch (error) {
                console.error('ì½”ë“œ í’ˆì§ˆ ë¶„ì„ ì˜¤ë¥˜:', error);
              }
              
              return issues;
            }
            
            // 4. ë°ì´í„°ë² ì´ìŠ¤ ë° ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§  
            async function checkDatabaseHealth() {
              console.log('ğŸ—„ï¸ ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§...');
              
              const issues = [];
              
              try {
                // SafeWork APIë¥¼ í†µí•œ DB ìƒíƒœ í™•ì¸
                const apiResponse = await fetch('${{ env.SAFEWORK_URL }}/api/health', {
                  timeout: 5000
                });
                
                if (apiResponse.ok) {
                  const healthData = await apiResponse.json();
                  
                  // DB ì‘ë‹µ ì‹œê°„ì´ 2ì´ˆ ì´ìƒì´ë©´ ì„±ëŠ¥ ì´ìŠˆ
                  if (healthData.database_response_time > 2000) {
                    issues.push({
                      title: `ğŸŒ ë°ì´í„°ë² ì´ìŠ¤ ì„±ëŠ¥ ì €í•˜ ê°ì§€`,
                      body: `ë°ì´í„°ë² ì´ìŠ¤ ì‘ë‹µ ì‹œê°„ì´ ë¹„ì •ìƒì ìœ¼ë¡œ ëŠë¦½ë‹ˆë‹¤.
                      
**ì„±ëŠ¥ ì§€í‘œ:**
- DB ì‘ë‹µ ì‹œê°„: ${healthData.database_response_time}ms
- ì„ê³„ê°’: 2000ms
- ê°ì§€ ì‹œê°„: ${new Date().toISOString()}

**ì„±ëŠ¥ ìµœì í™” í•„ìš”:**
- [ ] ìŠ¬ë¡œìš° ì¿¼ë¦¬ ë¶„ì„
- [ ] ì¸ë±ìŠ¤ ìµœì í™”
- [ ] ì»¤ë„¥ì…˜ í’€ ì ê²€
- [ ] ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ í™•ì¸`,
                      labels: ['P2-MEDIUM', 'component:database', 'automated']
                    });
                  }
                }
                
              } catch (error) {
                console.log('DB í—¬ìŠ¤ì²´í¬ ê±´ë„ˆë›°ê¸°:', error.message);
              }
              
              return issues;
            }
            
            // 5. í†µí•© ì´ìŠˆ ìƒì„± ë° ê´€ë¦¬
            async function createOrUpdateIssues(detectedIssues) {
              console.log(`ğŸ“ ${detectedIssues.length}ê°œ ì´ìŠˆ ì²˜ë¦¬ ì¤‘...`);
              
              for (const issue of detectedIssues) {
                try {
                  // ê¸°ì¡´ ìœ ì‚¬ ì´ìŠˆ í™•ì¸
                  const { data: existingIssues } = await github.rest.issues.listForRepo({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    state: 'open',
                    labels: 'automated',
                    per_page: 100
                  });
                  
                  const duplicate = existingIssues.find(existing => 
                    existing.title.includes(issue.title.split(' ').slice(-3).join(' '))
                  );
                  
                  if (!duplicate) {
                    // ìƒˆ ì´ìŠˆ ìƒì„±
                    await github.rest.issues.create({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      title: issue.title,
                      body: issue.body + '\\n\\n---\\nğŸ¤– **ìë™ ê°ì§€ ì‹œìŠ¤í…œ**ì— ì˜í•´ ìƒì„±ëœ ì´ìŠˆì…ë‹ˆë‹¤.',
                      labels: issue.labels
                    });
                    
                    console.log(`âœ… ìƒˆ ì´ìŠˆ ìƒì„±: ${issue.title}`);
                  } else {
                    console.log(`â­ï¸ ì¤‘ë³µ ì´ìŠˆ ê±´ë„ˆë›°ê¸°: ${issue.title}`);
                  }
                } catch (error) {
                  console.error(`âŒ ì´ìŠˆ ìƒì„± ì‹¤íŒ¨: ${issue.title}`, error);
                }
              }
            }
            
            // ë©”ì¸ ì‹¤í–‰ ë¡œì§
            async function runAutoDetection() {
              console.log('ğŸš€ SafeWork ìë™ ì´ìŠˆ ê°ì§€ ì‹œì‘...');
              
              const allIssues = [];
              
              // ëª¨ë“  ê°ì§€ í•¨ìˆ˜ ë³‘ë ¬ ì‹¤í–‰
              const [healthIssues, cicdIssues, qualityIssues, dbIssues] = await Promise.all([
                checkSystemHealth(),
                monitorCICDPipeline(), 
                analyzeCodeQuality(),
                checkDatabaseHealth()
              ]);
              
              allIssues.push(...healthIssues, ...cicdIssues, ...qualityIssues, ...dbIssues);
              
              if (allIssues.length > 0) {
                await createOrUpdateIssues(allIssues);
                console.log(`ğŸ¯ ì´ ${allIssues.length}ê°œ ì´ìŠˆ ê°ì§€ ë° ì²˜ë¦¬ ì™„ë£Œ`);
              } else {
                console.log('âœ… ê°ì§€ëœ ì´ìŠˆ ì—†ìŒ - ì‹œìŠ¤í…œ ì •ìƒ');
              }
            }
            
            await runAutoDetection();
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  # ê°ì§€ëœ ì´ìŠˆë¥¼ Slackìœ¼ë¡œ ì¦‰ì‹œ ì•Œë¦¼
  slack-alert:
    runs-on: ubuntu-latest
    needs: auto-detect-issues
    if: always()
    steps:
      - name: Send Detection Summary to Slack
        uses: actions/github-script@v7
        with:
          script: |
            const webhookUrl = process.env.SLACK_WEBHOOK_URL;
            if (!webhookUrl) {
              console.log('SLACK_WEBHOOK_URL not configured');
              return;
            }
            
            const payload = {
              channel: '#safework-alerts',
              text: 'ğŸ” SafeWork ìë™ ì´ìŠˆ ê°ì§€ ì™„ë£Œ',
              attachments: [{
                color: 'good',
                title: 'ğŸ¤– ìë™ ê°ì§€ ì‹œìŠ¤í…œ ì‹¤í–‰ ê²°ê³¼',
                fields: [
                  {
                    title: 'ì‹¤í–‰ ì‹œê°„',
                    value: new Date().toLocaleString('ko-KR', {timeZone: 'Asia/Seoul'}),
                    short: true
                  },
                  {
                    title: 'ê°ì§€ ë²”ìœ„',
                    value: 'ì‹œìŠ¤í…œ í—¬ìŠ¤, CI/CD, ì½”ë“œ í’ˆì§ˆ, DB ì„±ëŠ¥',
                    short: true
                  },
                  {
                    title: 'SafeWork ìƒíƒœ',
                    value: '<${{ env.SAFEWORK_URL }}|ì‹œìŠ¤í…œ í™•ì¸>',
                    short: false
                  }
                ],
                footer: 'SafeWork ìë™ ê°ì§€ ì‹œìŠ¤í…œ',
                ts: Math.floor(Date.now() / 1000)
              }]
            };
            
            const https = require('https');
            const url = require('url');
            
            const parsedUrl = url.parse(webhookUrl);
            const postData = JSON.stringify(payload);
            
            const options = {
              hostname: parsedUrl.hostname,
              port: parsedUrl.port || 443,
              path: parsedUrl.pathname,
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
                'Content-Length': Buffer.byteLength(postData)
              }
            };
            
            const req = https.request(options, (res) => {
              if (res.statusCode === 200) {
                console.log('Slack ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ');
              }
            });
            
            req.write(postData);
            req.end();
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}