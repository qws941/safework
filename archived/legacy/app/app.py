import os
import time as time_module
from datetime import datetime, timezone, timedelta

import redis
import pytz
from flask import Flask, flash, redirect, render_template, request, url_for
from flask_login import (
    LoginManager,
    current_user,
    login_required,
    login_user,
    logout_user,
)
from flask_migrate import Migrate

# from flask_wtf.csrf import CSRFProtect  # DISABLED FOR SURVEY TESTING

from config import config
from migration_manager import MigrationManager
from models import AuditLog, Survey, SurveyStatistics, User, db


def create_app(config_name=None):
    """Application factory with robust connection retry logic"""
    app = Flask(__name__)

    # KST ÏãúÍ∞ÑÎåÄ ÏÑ§Ï†ï (Asia/Seoul)
    kst_timezone = pytz.timezone('Asia/Seoul')
    app.config['TIMEZONE'] = kst_timezone
    app.config['DEFAULT_TIMEZONE'] = kst_timezone
    
    # ÏãúÏä§ÌÖú ÏãúÏûë ÏãúÍ∞Ñ Ï†ÄÏû• (KST)
    app.start_time = time_module.time()

    # Load configuration
    config_name = config_name or os.environ.get("FLASK_CONFIG", "production")
    app.config.from_object(config[config_name])

    # Fix APP_VERSION property object issue
    config_obj = config[config_name]()
    app.config["APP_VERSION"] = config_obj.APP_VERSION

    # CSRF Î≥¥Ìò∏ ÏôÑÏ†Ñ ÎπÑÌôúÏÑ±Ìôî - SURVEY TESTING
    app.config["WTF_CSRF_ENABLED"] = False
    app.config["WTF_CSRF_CHECK_DEFAULT"] = False
    app.config["WTF_CSRF_TIME_LIMIT"] = None
    app.config["SECRET_KEY_FALLBACK"] = app.config.get("SECRET_KEY", "fallback-key")

    # Flask-WTF CSRF ÏÑ§Ï†ï Í∞ïÏ†ú Ï†ÅÏö©
    import flask_wtf

    if hasattr(flask_wtf, "CSRFProtect"):
        app.extensions = getattr(app, "extensions", {})
        app.extensions.pop("csrf", None)

    # Enhanced database connection with retry and transaction handling
    def init_database_with_retry():
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ïó∞Í≤∞ Ïû¨ÏãúÎèÑ Î°úÏßÅ Î∞è Ìä∏ÎûúÏû≠ÏÖò ÏïàÏ†ïÏÑ± Í∞ïÌôî"""
        max_retries = int(os.environ.get("DB_CONNECTION_RETRIES", 60))
        retry_delay = int(os.environ.get("DB_CONNECTION_DELAY", 3))

        # Initialize DB and migration only once, outside the retry loop
        db.init_app(app)
        migrate = Migrate(app, db)

        # Enhanced SQLAlchemy pool configuration for transaction stability
        app.config["SQLALCHEMY_ENGINE_OPTIONS"].update({
            "pool_size": int(os.environ.get("DB_POOL_SIZE", 20)),  # Increased from 10
            "max_overflow": int(os.environ.get("DB_MAX_OVERFLOW", 30)),  # Add overflow
            "pool_timeout": int(os.environ.get("DB_POOL_TIMEOUT", 30)),
            "pool_recycle": int(os.environ.get("DB_POOL_RECYCLE", 1800)),  # 30 min recycle
            "pool_pre_ping": True,  # Always enable pre-ping
            "connect_args": {
                "connect_timeout": 10,
                "application_name": "safework_app",
                "options": "-c default_transaction_isolation=read_committed"
            }
        })

        for attempt in range(max_retries):
            try:
                # Test connection with transaction handling
                with app.app_context():
                    connection = db.engine.connect()
                    # Test transaction capability
                    transaction = connection.begin()
                    try:
                        connection.execute(db.text("SELECT 1"))
                        transaction.commit()
                    except Exception as tx_error:
                        transaction.rollback()
                        app.logger.warning(f"Transaction test failed: {tx_error}")
                        raise
                    finally:
                        connection.close()

                    app.logger.info(
                        f"‚úÖ Database connected with transaction support on attempt {attempt + 1}"
                    )
                    return True

            except Exception as e:
                if attempt < max_retries - 1:
                    app.logger.warning(
                        f"‚ö†Ô∏è Database connection attempt {attempt + 1} Ïò§Î•ò: {e}"
                    )
                    app.logger.info(f"üîÑ Retrying in {retry_delay} seconds...")
                    time_module.sleep(retry_delay)
                else:
                    app.logger.error(
                        f"‚ùå Database connection Ïò§Î•ò after {max_retries} attempts: {e}"
                    )
                    raise
        return False

    # Redis connection with retry logic
    def init_redis_with_retry():
        """Redis Ïó∞Í≤∞ Ïû¨ÏãúÎèÑ Î°úÏßÅ"""
        max_retries = int(os.environ.get("REDIS_CONNECTION_RETRIES", 10))
        retry_delay = int(os.environ.get("REDIS_CONNECTION_DELAY", 1))

        for attempt in range(max_retries):
            try:
                redis_client = redis.Redis(
                    host=app.config["REDIS_HOST"],
                    port=app.config["REDIS_PORT"],
                    password=app.config["REDIS_PASSWORD"],
                    db=app.config["REDIS_DB"],
                    decode_responses=True,
                    socket_connect_timeout=app.config.get(
                        "REDIS_SOCKET_CONNECT_TIMEOUT", 5
                    ),
                    socket_keepalive=app.config.get("REDIS_SOCKET_KEEPALIVE", True),
                    retry_on_timeout=True,
                    health_check_interval=30,
                )

                # Test connection
                redis_client.ping()
                app.redis = redis_client
                app.logger.info(
                    f"‚úÖ Redis connected ÏÉÅÌÉúÏ†ïÏÉÅ on attempt {attempt + 1}"
                )
                return True

            except Exception as e:
                if attempt < max_retries - 1:
                    app.logger.warning(
                        f"‚ö†Ô∏è Redis connection attempt {attempt + 1} Ïò§Î•ò: {e}"
                    )
                    app.logger.info(f"üîÑ Retrying in {retry_delay} seconds...")
                    time_module.sleep(retry_delay)
                else:
                    app.logger.error(
                        f"‚ùå Redis connection Ïò§Î•ò after {max_retries} attempts: {e}"
                    )
                    # Redis Ïã§Ìå®Îäî ÏπòÎ™ÖÏ†ÅÏù¥ÏßÄ ÏïäÏùå - Ï∫êÏãú ÏóÜÏù¥ ÎèôÏûë
                    app.redis = None
                    app.logger.warning("‚ö†Ô∏è Redis unavailable - running without cache")
                    return False
        return False

    # ÏùòÏ°¥ÏÑ± ÏàúÏÑúÎåÄÎ°ú Ï¥àÍ∏∞Ìôî
    app.logger.info("üöÄ SafeWork Ï¥àÍ∏∞Ìôî ÏãúÏûë...")

    # 1. Database Ï¥àÍ∏∞Ìôî (ÏµúÏö∞ÏÑ†)
    app.logger.info("1Ô∏è‚É£ Database Ïó∞Í≤∞ Ï§ë...")
    init_database_with_retry()

    # 2. Redis Ï¥àÍ∏∞Ìôî (ÏÑ†ÌÉùÏ†Å)
    app.logger.info("2Ô∏è‚É£ Redis Ïó∞Í≤∞ Ï§ë...")
    init_redis_with_retry()

    # Initialize migration manager
    migration_manager = MigrationManager(app)
    app.migration_manager = migration_manager

    # Initialize Login Manager
    login_manager = LoginManager()
    login_manager.init_app(app)
    login_manager.login_view = "auth.login"
    login_manager.login_message = "Ïù¥ ÌéòÏù¥ÏßÄÏóê Ï†ëÍ∑ºÌïòÎ†§Î©¥ Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§."

    @login_manager.user_loader
    def load_user(user_id):
        return db.session.get(User, int(user_id))

    # Add CSRF token to template context - DISABLED BUT PROVIDE EMPTY TOKEN FOR COMPATIBILITY
    @app.context_processor
    def inject_csrf_token():
        return dict(csrf_token=lambda: "")

    # Graceful connection check functions
    def check_database_health():
        """Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§ Ìó¨Ïä§Ï≤¥ÌÅ¨"""
        try:
            with app.app_context():
                db.engine.connect()
                return True
        except Exception as e:
            app.logger.error(f"Database health check Ïò§Î•ò: {e}")
            return False

    def check_redis_health():
        """Redis Ìó¨Ïä§Ï≤¥ÌÅ¨"""
        try:
            if app.redis:
                app.redis.ping()
                return True
            return False
        except Exception as e:
            app.logger.error(f"Redis health check Ïò§Î•ò: {e}")
            return False

    # Add health check functions to app
    app.check_database_health = check_database_health
    app.check_redis_health = check_redis_health

    # Register blueprints
    from routes.admin import admin_bp
    from routes.auth import auth_bp
    from routes.document import document_bp
    from routes.document_admin import document_admin_bp
    from routes.health import health_bp
    from routes.main import main_bp
    from routes.migration import migration_bp
    from routes.survey import survey_bp
    from routes.pdf_export import pdf_export_bp
    from routes.mobile_auth import mobile_auth_bp
    from routes.simple_ip import simple_ip_bp
    from routes.warning_sign import warning_sign_bp

    app.register_blueprint(main_bp)
    app.register_blueprint(auth_bp, url_prefix="/auth")
    app.register_blueprint(survey_bp, url_prefix="/survey")
    app.register_blueprint(admin_bp, url_prefix="/admin")
    app.register_blueprint(pdf_export_bp)
    app.register_blueprint(migration_bp, url_prefix="/admin")
    app.register_blueprint(mobile_auth_bp, url_prefix="/mobile")
    app.register_blueprint(simple_ip_bp)
    app.register_blueprint(health_bp)
    app.register_blueprint(document_bp, url_prefix="/documents")
    app.register_blueprint(document_admin_bp, url_prefix="/admin/documents")
    app.register_blueprint(warning_sign_bp, url_prefix="/warning-sign")

    # SafeWork API routes (v2.0)
    try:
        from routes.api_safework_v2 import api_safework_bp

        app.register_blueprint(api_safework_bp, url_prefix="/api/safework/v2")
        app.logger.info("‚úÖ SafeWork API v2.0 loaded ÏÉÅÌÉúÏ†ïÏÉÅ")
    except ImportError as e:
        app.logger.warning(f"‚ö†Ô∏è SafeWork API v2.0 not loaded: {e}")

    # Enhanced error handlers with PostgreSQL transaction recovery
    @app.errorhandler(404)
    def not_found_error(error):
        return render_template("errors/404.html"), 404

    @app.errorhandler(500)
    def internal_error(error):
        """Enhanced 500 error handler with PostgreSQL transaction recovery"""
        try:
            # Check for PostgreSQL transaction errors
            error_msg = str(error) if error else ""
            if "InFailedSqlTransaction" in error_msg or "current transaction is aborted" in error_msg:
                app.logger.warning("PostgreSQL transaction error detected - performing recovery")
                # Force rollback and close connection
                try:
                    db.session.rollback()
                    db.session.close()
                    # Remove session to force new connection
                    db.session.remove()
                    app.logger.info("PostgreSQL transaction recovery completed")
                except Exception as recovery_error:
                    app.logger.error(f"Transaction recovery failed: {recovery_error}")
            else:
                # Standard rollback for other errors
                db.session.rollback()
        except Exception as rollback_error:
            app.logger.warning(f"Cannot rollback database session: {rollback_error}")

        return render_template("errors/500.html"), 500

    # Add database error handling middleware
    @app.before_request
    def handle_database_recovery():
        """Pre-request PostgreSQL connection health check"""
        try:
            # Check if we have a healthy database session
            if hasattr(db.session, 'is_active') and not db.session.is_active:
                db.session.close()
                db.session.remove()
        except Exception as e:
            app.logger.warning(f"Database health check warning: {e}")
            try:
                db.session.rollback()
                db.session.remove()
            except Exception:
                pass

    # ÏÑ∏ÏÖò Ï§ëÎ≥µ Î∞©ÏßÄ Í≤ÄÏ¶ù ÎØ∏Îì§Ïõ®Ïñ¥
    @app.before_request
    def validate_session():
        """ÏÑ∏ÏÖò Ï§ëÎ≥µ Î∞©ÏßÄÎ•º ÏúÑÌïú Í≤ÄÏ¶ù"""
        from flask_login import current_user
        from flask import session as flask_session, request
        from utils.session_manager import session_manager

        # Î°úÍ∑∏Ïù∏Ïù¥ ÌïÑÏöîÌïòÏßÄ ÏïäÏùÄ ÏóîÎìúÌè¨Ïù∏Ìä∏Îäî Í±¥ÎÑàÎõ∞Í∏∞
        if request.endpoint in ['auth.login', 'auth.register', 'main.index', 'health.health', 'static']:
            return

        # Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏóîÎìúÌè¨Ïù∏Ìä∏ÎèÑ Í±¥ÎÑàÎõ∞Í∏∞
        if request.path.startswith('/health') or request.path.startswith('/api/health'):
            return

        # ÌòÑÏû¨ ÏÇ¨Ïö©ÏûêÍ∞Ä Ïù∏Ï¶ùÎêú ÏÉÅÌÉúÏù∏ÏßÄ ÌôïÏù∏
        if current_user.is_authenticated:
            safework_session_id = flask_session.get('safework_session_id')

            # SafeWork ÏÑ∏ÏÖò IDÍ∞Ä ÏóÜÍ±∞ÎÇò Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Í≤ΩÏö∞
            if not safework_session_id or not session_manager.validate_session(current_user.id, safework_session_id):
                app.logger.warning(f"Invalid session detected for user {current_user.id}, logging out")

                # Í∞ïÏ†ú Î°úÍ∑∏ÏïÑÏõÉ
                from flask_login import logout_user
                logout_user()
                flask_session.clear()

                from flask import flash, redirect, url_for
                flash("ÏÑ∏ÏÖòÏù¥ ÎßåÎ£åÎêòÏóàÍ±∞ÎÇò Îã§Î•∏ Í≥≥ÏóêÏÑú Î°úÍ∑∏Ïù∏ÌïòÏó¨ ÏûêÎèô Î°úÍ∑∏ÏïÑÏõÉÎêòÏóàÏäµÎãàÎã§.", "warning")
                return redirect(url_for('auth.login'))

    # Enhanced health endpoint
    @app.route("/health/detailed")
    def detailed_health():
        """ÏÉÅÏÑ∏ Ìó¨Ïä§Ï≤¥ÌÅ¨ ÏóîÎìúÌè¨Ïù∏Ìä∏"""
        health_status = {
            "service": "safework",
            "status": "healthy",
            "timestamp": datetime.now(app.config['TIMEZONE']).isoformat(),
            "components": {
                "database": check_database_health(),
                "redis": check_redis_health(),
                "application": True,
            },
        }

        # ÌïòÎÇòÎùºÎèÑ Ïã§Ìå®ÌïòÎ©¥ Ï†ÑÏ≤¥ ÏÉÅÌÉúÎ•º unhealthyÎ°ú Î≥ÄÍ≤Ω
        if not all(
            [
                health_status["components"]["database"],
                health_status["components"]["application"],
            ]
        ):
            health_status["status"] = "unhealthy"

        return health_status, 200 if health_status["status"] == "healthy" else 503

    # Context processors
    @app.context_processor
    def inject_config():
        config_obj = app.config
        kst_timezone = app.config['TIMEZONE']

        # URL Ï†ïÎ≥¥ Ï∂îÍ∞Ä
        url_info = {
            "current_url": config_obj.get("DEV_URL")
            if config_obj.get("FLASK_CONFIG") == "development"
            else config_obj.get("PRD_URL")
            if config_obj.get("FLASK_CONFIG") == "production"
            else config_obj.get("LOCAL_URL", "http://localhost:4545"),
            "dev_url": config_obj.get("DEV_URL", "https://safework-dev.jclee.me"),
            "prd_url": config_obj.get("PRD_URL", "https://safework.jclee.me"),
            "local_url": config_obj.get("LOCAL_URL", "http://localhost:4545"),
            "environment": config_obj.get("FLASK_CONFIG", "development"),
        }

        # ÏõåÌÅ¨ÌîåÎ°úÏö∞ÏóêÏÑú ÏÉùÏÑ±Îêú Git ÌÉúÍ∑∏ Í∏∞Î∞ò Î≤ÑÏ†Ñ ÌëúÏãú
        try:
            import subprocess

            result = subprocess.run(
                ["git", "describe", "--tags", "--exact-match"],
                capture_output=True,
                text=True,
                timeout=2,
            )

            if result.returncode == 0:
                app_version = result.stdout.strip()
                version_info = {
                    "version": app_version,
                    "source": "workflow-tag",
                    "note": "Version from GitHub Actions workflow tag",
                }
            else:
                result = subprocess.run(
                    ["git", "rev-parse", "--short", "HEAD"],
                    capture_output=True,
                    text=True,
                    timeout=2,
                )
                if result.returncode == 0:
                    timestamp = datetime.now(kst_timezone).strftime("%Y%m%d-%H%M")
                    app_version = f"v3.0.{timestamp}-{result.stdout.strip()}"
                    version_info = {
                        "version": app_version,
                        "source": "git-sha",
                        "note": "Temporary version from Git SHA",
                    }
                else:
                    raise Exception("Git command Ïò§Î•ò")
        except Exception:
            app_version = "3.0.0"
            version_info = {
                "version": app_version,
                "source": "config-fallback",
                "note": "Fallback static version",
            }

        # ÏãúÏä§ÌÖú ÏóÖÌÉÄÏûÑ Í≥ÑÏÇ∞
        uptime_seconds = time_module.time() - app.start_time
        uptime_days = int(uptime_seconds // 86400)
        uptime_hours = int((uptime_seconds % 86400) // 3600)
        uptime_minutes = int((uptime_seconds % 3600) // 60)

        if uptime_days > 0:
            uptime_str = f"{uptime_days}Ïùº {uptime_hours}ÏãúÍ∞Ñ {uptime_minutes}Î∂Ñ"
        elif uptime_hours > 0:
            uptime_str = f"{uptime_hours}ÏãúÍ∞Ñ {uptime_minutes}Î∂Ñ"
        else:
            uptime_str = f"{uptime_minutes}Î∂Ñ"

        return {
            "app_name": app.config["APP_NAME"],
            "app_version": app_version,
            "version_info": version_info,
            "system_uptime": uptime_str,
            "start_time": datetime.fromtimestamp(
                app.start_time, tz=kst_timezone
            ).strftime("%Y-%m-%d %H:%M:%S KST"),
            "url_info": url_info,
        }

    # Audit logging with error handling
    @app.before_request
    def log_request():
        if current_user.is_authenticated:
            if request.endpoint and "admin" in request.endpoint:
                # ÏûÑÏãúÎ°ú Í∞êÏÇ¨ Î°úÍ∑∏ ÎπÑÌôúÏÑ±Ìôî - ÌîÑÎ°úÎçïÏÖò Ïä§ÌÇ§Îßà Ìò∏ÌôòÏÑ± Î¨∏Ï†ú
                pass

    app.logger.info("‚úÖ SafeWork Ï¥àÍ∏∞Ìôî ÏôÑÎ£å!")
    return app


# Create application instance for gunicorn
app = create_app()

if __name__ == "__main__":
    # Run directly in development - use APP_PORT environment variable
    port = int(os.environ.get("APP_PORT", 5000))
    app.run(host="0.0.0.0", port=port, debug=False)
